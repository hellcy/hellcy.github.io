<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://hellcy.github.io/atom.xml" rel="self"/>
  
  <link href="http://hellcy.github.io/"/>
  <updated>2022-06-23T17:06:29.482Z</updated>
  <id>http://hellcy.github.io/</id>
  
  <author>
    <name>Yuan Cheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Testing React with Jest and RTL</title>
    <link href="http://hellcy.github.io/2022/06/22/Testing-React-with-Jest-and-RTL/"/>
    <id>http://hellcy.github.io/2022/06/22/Testing-React-with-Jest-and-RTL/</id>
    <published>2022-06-22T00:38:44.000Z</published>
    <updated>2022-06-23T17:06:29.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jest-and-enzyme"><a class="markdownIt-Anchor" href="#jest-and-enzyme"></a> Jest and Enzyme</h1><ul><li>Jest is a fully feature testing framework not just for React</li><li>Enzyme is a library that makes testing React components specifically easier</li><li>If you are using React in your application, it might make sense to use Enzyme and Jest together to automatically test your UI</li><li>Many people use Jest as a test runner and assertion library, then use Enzyme to build the tests for their UI</li></ul><h2 id="jest-compares-snapshots"><a class="markdownIt-Anchor" href="#jest-compares-snapshots"></a> Jest compares snapshots</h2><ul><li>Snapshot is a saved fragment of HTML generated by your application</li><li>when Jest run tests, it compares the output of rendering a component with the saved snapshot HTML, it they are the same, then the tests passes.</li></ul><h3 id="issues-with-snapshots"><a class="markdownIt-Anchor" href="#issues-with-snapshots"></a> Issues with snapshots</h3><ul><li>if your component has many states, you have to create a snapshot for each state.</li></ul><h2 id="enzyme"><a class="markdownIt-Anchor" href="#enzyme"></a> Enzyme</h2><ul><li>Enzyme renders the component in memory, then provides a series of APIs to examine the component’s properties</li></ul><h3 id="shallow-rendering"><a class="markdownIt-Anchor" href="#shallow-rendering"></a> Shallow rendering</h3><ul><li>only render that component itself, Enzyme doesn’t render any of the children of that component</li><li>then you could use functions like <code>find()</code> or <code>findWhere()</code> to find the element within the component</li></ul><h3 id="full-rendering"><a class="markdownIt-Anchor" href="#full-rendering"></a> Full rendering</h3><ul><li>useful for integration testing, where you need to test multiple components and how they work together</li></ul><h1 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h1><h2 id="create-react-app"><a class="markdownIt-Anchor" href="#create-react-app"></a> Create react app</h2><ul><li>npm package</li><li>Creates react application with<ul><li>configuration</li><li>webpack and babel<ul><li>webpack will bundle all your code in one file</li><li>babel will translate react to the code that our browser can understand</li></ul></li><li>web server<ul><li>to run our app on localhost</li></ul></li><li>testing library</li></ul></li></ul><h2 id="npx"><a class="markdownIt-Anchor" href="#npx"></a> npx</h2><ul><li>downloads the latest version of create-react-app templates every time</li><li>not dependent on when you last installed create-react-app<ul><li>it is never installed on your laptop</li></ul></li></ul><h2 id="breaking-down-syntax"><a class="markdownIt-Anchor" href="#breaking-down-syntax"></a> Breaking down syntax</h2><ul><li>render<ul><li>create virtual DOM for argument JSX</li></ul></li><li>screen<ul><li>global object to access virtual DOM</li><li><code>screen.getByText()</code> to find element by display text</li></ul></li><li>expect<ul><li>assertion, causes test to succeed to fail</li></ul></li></ul><h2 id="jest-and-react-testing-library"><a class="markdownIt-Anchor" href="#jest-and-react-testing-library"></a> Jest and React Testing Library</h2><ul><li>React Testing Library helps with<ul><li>rendering components into virtual DOM</li><li>searching virtual DOM</li><li>interacting with virtual DOM</li></ul></li><li>needs a test runner<ul><li>find tests, run them, make assertions</li></ul></li><li>Jest is the test runner<ul><li>is recommended by Testing Library</li><li>comes with create-react-app</li></ul></li><li><code>npm test</code> runs an npm script that runs Jest in watch mode</li></ul><h2 id="jest-watch-mode"><a class="markdownIt-Anchor" href="#jest-watch-mode"></a> Jest Watch mode</h2><ul><li>watch for changes in files since last commit</li><li>only run tests related to these files</li><li>no changes? no tests.</li></ul><h2 id="how-does-jest-work"><a class="markdownIt-Anchor" href="#how-does-jest-work"></a> How does Jest work</h2><ul><li>global <code>test</code> method has two arguments<ul><li>string description</li><li>test function</li></ul></li><li>test fails if error is thrown when running function<ul><li>assertions throw errors when expectation fails</li></ul></li><li>no error -&gt; tests pass<ul><li>empty test passes</li></ul></li></ul><h2 id="tdd"><a class="markdownIt-Anchor" href="#tdd"></a> TDD</h2><ul><li>write tests before writing code<ul><li>then write code according to spec set by tests</li></ul></li><li>red green testing<ul><li>tests fail before code is written</li></ul></li></ul><h2 id="react-testing-library"><a class="markdownIt-Anchor" href="#react-testing-library"></a> React Testing Library</h2><ul><li>creates virtual DOM for testing<ul><li>and utilities for interacting with DOM</li></ul></li><li>allows testing without a browser</li></ul><h2 id="types-of-tests"><a class="markdownIt-Anchor" href="#types-of-tests"></a> Types of tests</h2><ul><li>Unit test<ul><li>tests one unit of code in isolation</li><li>mock dependencies, test internals</li><li>easy to pinpoint failures but further from how users interact with software</li><li>more likely to break with refactoring</li></ul></li><li>Integration tests<ul><li>how multiple units work together</li></ul></li><li>functional tests<ul><li>tests a particular function of software</li><li>you are not testing your code, you are testing a behavior</li><li>close to how users interact with software</li><li>more difficult to debug failing tests (tests are not tightly coupled with the code)</li><li>e.g. enter data in form and click submit</li></ul></li><li>acceptance E2E tests<ul><li>use actual browser and server (Cypress, Selenium)</li></ul></li></ul><h2 id="bdd"><a class="markdownIt-Anchor" href="#bdd"></a> BDD</h2><ul><li>Behavior driven development</li><li>testing library encourages testing behavior over implementation</li><li>but we still call it TDD, why?</li><li>because BDD is very explicitly defined<ul><li>involves collaboration between lots of roles</li><li>developers, QA, business partners, etc…</li><li>defines process for different groups to interact</li></ul></li></ul><h2 id="unit-testing-functions"><a class="markdownIt-Anchor" href="#unit-testing-functions"></a> Unit testing functions</h2><ul><li>functions separate from components<ul><li>used by several components</li><li>complex logic</li></ul></li><li>unit test if<ul><li>complex logic difficult to test via functional tests</li><li>too many edge cases</li></ul></li></ul><h2 id="review"><a class="markdownIt-Anchor" href="#review"></a> Review</h2><ul><li>Test interactivity using <code>fireEvent</code><ul><li><code>userEvent</code> is more popular than <code>fireEvent</code></li></ul></li><li>jest DOM assertions<ul><li><code>toBeEnabled()</code></li><li><code>toBeDisabled()</code></li><li><code>toBeChecked()</code></li></ul></li><li><code>getByRole</code> option <code>name</code></li><li>jest <code>describe</code> to group tests</li></ul><h1 id="eslint-and-prettier"><a class="markdownIt-Anchor" href="#eslint-and-prettier"></a> ESLint and Prettier</h1><h2 id="eslint"><a class="markdownIt-Anchor" href="#eslint"></a> ESLint</h2><ul><li>Linter<ul><li>analyzes static text and marks syntax that breaks rules</li></ul></li><li>Static<ul><li>analyze code as written, not what happens when code is run</li></ul></li><li>Popular linter for JavaScript</li><li>linting keeps code style consistent<ul><li>especially for multi engineer projects</li></ul></li><li>also catches errors in code<ul><li>using variable before defining</li><li>importing from non-existing file</li><li>etc…</li></ul></li></ul><h2 id="linting-vs-formatting"><a class="markdownIt-Anchor" href="#linting-vs-formatting"></a> Linting vs Formatting</h2><ul><li>Formatters (like prettier) automatically format code</li><li>linters address format and code style<ul><li>enforce best practices</li></ul></li></ul><h1 id="sundaes-on-demand-form-review-and-popover"><a class="markdownIt-Anchor" href="#sundaes-on-demand-form-review-and-popover"></a> Sundaes on Demand: Form review and popover</h1><ul><li>more complex user interactions<ul><li>multiple form entry, moving through order phases</li></ul></li><li>mouseover popup<ul><li>test that element disappears from DOM</li></ul></li><li>simulating server response<ul><li>mock service worker (without the need of a real backend server)</li><li>mock responses from server</li></ul></li><li>async app updates<ul><li>tell assertion to wait until DOM changes</li></ul></li><li>global state via context</li></ul><h2 id="code-organization"><a class="markdownIt-Anchor" href="#code-organization"></a> Code organization</h2><ul><li>organize components by pages<ul><li><code>test</code> directory for each page</li><li>Jest will find and run any files that end in <code>.test.js</code></li></ul></li></ul><h2 id="screen-query-methods"><a class="markdownIt-Anchor" href="#screen-query-methods"></a> screen Query methods</h2><ul><li>get: expect element to be in DOM</li><li>query: expect element NOT to be in DOM</li><li>find: expect element to appear async</li></ul><h2 id="check-that-tests-can-fail"><a class="markdownIt-Anchor" href="#check-that-tests-can-fail"></a> Check that tests can fail</h2><ul><li>sometimes tests pass because of async and assertions don’t have a chance to run before the tests end.</li><li>so it is a good habit to check that the tests can fail as well as pass</li></ul><h2 id="wait-for-element-to-disappear"><a class="markdownIt-Anchor" href="#wait-for-element-to-disappear"></a> wait for element to disappear</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; popover disappears when we mouse out</span><br><span class="line">userEvent.unhover(termsAndConditions);</span><br><span class="line">await waitForElementToBeRemoved(() &#x3D;&gt;</span><br><span class="line">  screen.queryByText(&#x2F;no ice cream will actually be delivered&#x2F;i)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>sometimes the disappearance of elements is happening asynchronously, so we need to wait for it before doing assertions</li></ul><h2 id="review-2"><a class="markdownIt-Anchor" href="#review-2"></a> Review</h2><ul><li><code>userEvent.hover</code> and <code>userEvent.unhover</code></li><li><code>queryByText</code></li><li><code>async waitForElementToBeRemoved</code></li><li><code>test not wrapped in act(...)</code> warning<ul><li>determine how component is getting updated async and account for in tests</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jest-and-enzyme&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jest-and-enzyme&quot;&gt;&lt;/a&gt; Jest and Enzyme&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Jest is a fully feature tes</summary>
      
    
    
    
    
    <category term="React" scheme="http://hellcy.github.io/tags/React/"/>
    
    <category term="Testing" scheme="http://hellcy.github.io/tags/Testing/"/>
    
    <category term="Jest" scheme="http://hellcy.github.io/tags/Jest/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL and React</title>
    <link href="http://hellcy.github.io/2022/06/18/GraphQL-and-React/"/>
    <id>http://hellcy.github.io/2022/06/18/GraphQL-and-React/</id>
    <published>2022-06-18T03:29:44.000Z</published>
    <updated>2022-06-20T13:36:06.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="a-restful-routing-primer"><a class="markdownIt-Anchor" href="#a-restful-routing-primer"></a> A RESTful routing primer</h1><ul><li>given a collection of records on a server, there should be a uniform URL and HTTP request method used to utilize that collection of records. (doing CRUD operations to that data)</li><li>GraphQL can fix some issues in Restful routing and over serving data</li></ul><h1 id="on-to-graphql"><a class="markdownIt-Anchor" href="#on-to-graphql"></a> On to GraphQL</h1><ul><li>Graph is all the data and their relationships in a database.</li><li>we define a query and it starts at some node, then follow the edges to get the other data we want</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    friends &#123;</span><br><span class="line">      company &#123;</span><br><span class="line">        name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Express is handling our requests, if the request is a GraphQL query, it will hand the request to the GraphQL. The response from GraphQL will be send back to Express which will then be sent back to the application</li><li>application -&gt; Express -&gt; GraphQL</li><li>application &lt;- Express &lt;- GraphQL</li></ul><h1 id="fetching-data-with-queries"><a class="markdownIt-Anchor" href="#fetching-data-with-queries"></a> Fetching data with queries</h1><ul><li>Resolve function is like an edge in the Graph, it has the parent value and arguments, and takes us to the next node in the graph, to fetch the piece of data we want</li></ul><h2 id="the-circular-reference-error"><a class="markdownIt-Anchor" href="#the-circular-reference-error"></a> The circular reference error</h2><ul><li>in JS, you cannot refer to a variable before it has been defined. But in GraphQL, it is common to have circular reference, e.g. A USER is working at a COMPANY. and this COMPANY has this USER. So we need to have resolve this circular reference problem</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const UserType &#x3D; new GraphQLObject(&#123;</span><br><span class="line">  name: &quot;User&quot;,</span><br><span class="line">  fields: () &#x3D;&gt; (&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>the solution is to wrap the definition of fields into an arrow function. So JS will first define all the variables, but will not execute any functions. Then in GraphQL internally it will invoke this anonymous functions. And inside these <strong>CLOSURES</strong> we already have defined all these variables.</li></ul><h2 id="fragment"><a class="markdownIt-Anchor" href="#fragment"></a> Fragment</h2><ul><li>a fragment is just a list of properties of an object, by defining a fragment so you don’t have to duplicate all that properties in your query</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  apple: company(id: &quot;1&quot;) &#123;</span><br><span class="line">    ...companyDetails</span><br><span class="line">  &#125;</span><br><span class="line">  google: company(id: &quot;2&quot;) &#123;</span><br><span class="line">    ...companyDetails</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fragment companyDetails on Company &#123;</span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    description</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mutation"><a class="markdownIt-Anchor" href="#mutation"></a> Mutation</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Mutation is to make changes to the data</span><br><span class="line"> * fields of the mutation describe the operation that this mutation is going to undertake</span><br><span class="line"> *&#x2F;</span><br><span class="line">const mutation &#x3D; new GraphQLObjectType(&#123;</span><br><span class="line">  name: &quot;Mutation&quot;,</span><br><span class="line">  fields: &#123;</span><br><span class="line">    addUser: &#123;</span><br><span class="line">      type: UserType,</span><br><span class="line">      args: &#123;</span><br><span class="line">        firstName: &#123; type: new GraphQLNonNull(GraphQLString) &#125;,</span><br><span class="line">        age: &#123; type: new GraphQLNonNull(GraphQLInt) &#125;,</span><br><span class="line">        companyId: &#123; type: GraphQLString &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      resolve(parentValue, &#123; firstName, age &#125;) &#123;</span><br><span class="line">        return axios</span><br><span class="line">          .post(&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;users&quot;, &#123; firstName, age &#125;)</span><br><span class="line">          .then((res) &#x3D;&gt; res.data);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * GraphQLSchema takes a RootQuery and returns a new instance of GraphQL Schema</span><br><span class="line"> * we can use this schema in our Express application</span><br><span class="line"> *&#x2F;</span><br><span class="line">module.exports &#x3D; new GraphQLSchema(&#123;</span><br><span class="line">  query: RootQuery,</span><br><span class="line">  mutation,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>mutation query from Graphiql</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutation &#123;</span><br><span class="line">  addUser(firstName: &quot;Yuan&quot;, age: 28) &#123;</span><br><span class="line">    id,</span><br><span class="line">    firstName,</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>new data is also present in the db.json file, notice json-server will automatically assign an ID to our new User</li></ul><h2 id="put-and-patch"><a class="markdownIt-Anchor" href="#put-and-patch"></a> PUT and PATCH</h2><ul><li>PUT request will completely replace the data record with the one in the request</li><li>PATCH request will only update the data attributes in the record, and leave the existing data attributes untouched</li></ul><h1 id="history-of-data-transport"><a class="markdownIt-Anchor" href="#history-of-data-transport"></a> History of data transport</h1><ul><li>RPC -&gt; SOAP -&gt; REST -&gt; GraphQL</li></ul><h2 id="over-fetching"><a class="markdownIt-Anchor" href="#over-fetching"></a> Over-fetching</h2><ul><li>REST API will likely to give us more data points than we need</li><li>GraphQL can give us the exact data we need in the shape we want</li></ul><h2 id="under-fetching"><a class="markdownIt-Anchor" href="#under-fetching"></a> Under-fetching</h2><ul><li>if we want to get the details of an actor and all the movies he played using Rest API.</li><li>firstly we need to make a request to get the actor details. Then for each movie we need to make a separate API request to get the movie details.</li><li>But if we are using GraphQL, because the Actor and the Movie are related, we could use nested query to get all the data in one request.</li></ul><h2 id="one-endpoint"><a class="markdownIt-Anchor" href="#one-endpoint"></a> One endpoint</h2><ul><li>using Rest API often requires us to make many endpoints to suit our needs. That means our front and backend teams have to spend a lot of time together working out their needs.</li><li>GraphQL only has one endpoint, all data are related and defined in a well structured schema file.</li><li>Many companies use Rest and GraphQL together, setting up a GraphQL endpoint that fetches data from REST endpoints is a perfectly valid way to use GraphQL</li></ul><h2 id="graphql-clients"><a class="markdownIt-Anchor" href="#graphql-clients"></a> GraphQL clients</h2><ul><li>speed the workflow for developers teams and improve the efficiency and performance of applications.</li><li>They handle tasks like network requests, data caching, and injecting data into the UI.</li><li>Relay and Apollo</li></ul><h1 id="the-graphql-query-language"><a class="markdownIt-Anchor" href="#the-graphql-query-language"></a> The GraphQL Query Language</h1><ul><li>GraphQL is like SQL, they are both query language, doing CRUD operations with data.</li><li>the difference is SQL is doing operations directly to the database. But GraphQL needs to be sent over the internet or API.</li><li>SQL is a query language for databases, GraphQL is a query language for the Internet.</li></ul><h2 id="graphql-api-tools"><a class="markdownIt-Anchor" href="#graphql-api-tools"></a> GraphQL API tools</h2><ul><li>for testing GraphQL queries against a GraphQL API: GraphiQL and GraphQL Playground</li></ul><h2 id="query-types"><a class="markdownIt-Anchor" href="#query-types"></a> Query Types</h2><ul><li>there are five types in GraphQL<ul><li>Int</li><li>Float</li><li>String</li><li>Boolean</li><li>ID (unique String)</li></ul></li></ul><h2 id="fragment-2"><a class="markdownIt-Anchor" href="#fragment-2"></a> Fragment</h2><ul><li>selection sets that can be reused in multiple operations</li><li>Fragment must be associated with a type</li><li>you could also write inline fragment</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  getInfo &#123;</span><br><span class="line">    ...fragInfo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment fragInfo on Info &#123;</span><br><span class="line">  field1</span><br><span class="line">  field2</span><br><span class="line">  field3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="inline-fragment"><a class="markdownIt-Anchor" href="#inline-fragment"></a> Inline fragment</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  ...on Info &#123;</span><br><span class="line">    field1</span><br><span class="line">    field2</span><br><span class="line">    field3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>inline fragment is like an anonymous fragment</li></ul><h2 id="mutation-2"><a class="markdownIt-Anchor" href="#mutation-2"></a> Mutation</h2><ul><li>make changes to data</li></ul><h2 id="subscription"><a class="markdownIt-Anchor" href="#subscription"></a> Subscription</h2><ul><li>when the subscription is sent to the server, the subscription is listening for any changes to the data</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">subscription &#123;</span><br><span class="line">  infoChange &#123;</span><br><span class="line">    field1</span><br><span class="line">    field2</span><br><span class="line">    field3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>the subscription remains open until you close it.</li></ul><h2 id="introspection"><a class="markdownIt-Anchor" href="#introspection"></a> Introspection</h2><ul><li>query details about the current API’s schema</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;a-restful-routing-primer&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#a-restful-routing-primer&quot;&gt;&lt;/a&gt; A RESTful routing primer&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="GraphQL" scheme="http://hellcy.github.io/tags/GraphQL/"/>
    
    <category term="React" scheme="http://hellcy.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis Basics</title>
    <link href="http://hellcy.github.io/2022/02/21/MyBatis-Basics/"/>
    <id>http://hellcy.github.io/2022/02/21/MyBatis-Basics/</id>
    <published>2022-02-21T11:21:51.000Z</published>
    <updated>2022-02-22T12:49:16.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件开发中的框架"><a class="markdownIt-Anchor" href="#软件开发中的框架"></a> 软件开发中的框架</h1><ul><li>框架是可被应用开发者定制的应用骨架</li><li>框架是一种规则，保证开发者遵循相同的方式开发程序</li><li>不重复造轮子，对基础功能进行封装</li></ul><h1 id="框架的优点"><a class="markdownIt-Anchor" href="#框架的优点"></a> 框架的优点</h1><ul><li>提高开发效率</li><li>统一的编码规则，利于团队管理</li><li>灵活配置的应用，拥有更好的维护性</li></ul><h1 id="ssm开发框架"><a class="markdownIt-Anchor" href="#ssm开发框架"></a> SSM开发框架</h1><ul><li>Spring<ul><li>框架的框架</li></ul></li><li>SpringMVC<ul><li>对程序解耦，替代Servlet进行web开发</li></ul></li><li>MyBatis<ul><li>简化数据库交互，对JDBC进行了封装和扩展</li></ul></li></ul><h1 id="什么是mybatis"><a class="markdownIt-Anchor" href="#什么是mybatis"></a> 什么是MyBatis</h1><ul><li>持久层框架 DAO</li><li>使用XML将SQL与程序解耦，便于维护<ul><li>当SQL需要改变时，只需要改变XML文件，不需要重新编译</li></ul></li><li>学习简单，执行高效，是JDBC的延伸</li></ul><h1 id="mybatis开发流程"><a class="markdownIt-Anchor" href="#mybatis开发流程"></a> MyBatis开发流程</h1><ul><li>引入MyBatis依赖（使用Maven）</li><li>创建核心配置文件</li><li>创建实体类（entity， POJO）</li><li>创建Mapper映射文件（AutoMapper）</li><li>初始化SessionFactory<ul><li>读取配置文件，加载Mapper映射</li></ul></li><li>利用SqlSession对象操作数据</li></ul><h1 id="单元测试与junit"><a class="markdownIt-Anchor" href="#单元测试与junit"></a> 单元测试与Junit</h1><ul><li>单元测试是指对软件中的最小可测试单元进行检查和验证</li><li>测试用例（test case）是指编写一段代码对已有功能进行校验</li><li>Junit是Java中最著名的单元测试工具</li></ul><h2 id="junit使用方法"><a class="markdownIt-Anchor" href="#junit使用方法"></a> Junit使用方法</h2><ul><li>引入Junit JAR或者增加Maven依赖</li><li>编写测试用例验证目标方法是否正确运行</li><li>在测试用例上增加@Test注解开始单元测试</li></ul><h1 id="mybatis环境配置"><a class="markdownIt-Anchor" href="#mybatis环境配置"></a> MyBatis环境配置</h1><ul><li>mybatis-config.xml</li><li>XML格式配置数据库环境信息</li><li>包含数据库驱动，URL，用户名，密码</li></ul><p><img src="/images/MyBatis-Basics/1.png" alt="" /></p><h2 id="mybatis-configxml"><a class="markdownIt-Anchor" href="#mybatis-configxml"></a> mybatis-config.xml</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;environments default&#x3D;&quot;dev&quot;&gt;</span><br><span class="line">        &lt;environment id&#x3D;&quot;dev&quot;&gt;</span><br><span class="line">            &lt;!-- use JDBC to control DB transaction commit and rollback--&gt;</span><br><span class="line">            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;&lt;&#x2F;transactionManager&gt;</span><br><span class="line">            &lt;!-- use data connection pool to manager DB connections --&gt;</span><br><span class="line">            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;babytun?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;yuan&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;1111&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;dataSource&gt;</span><br><span class="line">        &lt;&#x2F;environment&gt;</span><br><span class="line">        &lt;!-- another env --&gt;</span><br><span class="line">        &lt;environment id&#x3D;&quot;prd&quot;&gt;</span><br><span class="line">            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;&lt;&#x2F;transactionManager&gt;</span><br><span class="line">            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;192.168.1.155:3306&#x2F;babytun?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;yuan&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;1111&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;dataSource&gt;</span><br><span class="line">        &lt;&#x2F;environment&gt;</span><br><span class="line">    &lt;&#x2F;environments&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><h2 id="sqlsessionfactory"><a class="markdownIt-Anchor" href="#sqlsessionfactory"></a> SqlSessionFactory</h2><ul><li>MyBatis的核心对象</li><li>初始化MyBatis，创建SqlSession对象</li><li>保证SqlSessionFactory在应用中全局唯一</li></ul><h2 id="sqlsession"><a class="markdownIt-Anchor" href="#sqlsession"></a> SqlSession</h2><ul><li>是MyBatis操作数据库的核心对象</li><li>使用JDBC方式与数据库交互，是原有JDBC的扩展</li><li>提供了数据表CRUD对应方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void testSqlSessionFactory() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 利用Reader加载classpath下的mybatis配置文件</span><br><span class="line">      Reader reader &#x3D; Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 初始化SqlSessionFactory对象，同时解析mybatis-config.xml文件</span><br><span class="line">      SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">      System.out.println(&quot;SessionFactory loaded&quot;);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 创建SqlSession对象，是JDBC的扩展类，用于与数据库交互</span><br><span class="line">      SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建数据库连接，只是用于测试，工程中不需要显示创建连接</span><br><span class="line">        Connection connection &#x3D; sqlSession.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        if (sqlSession !&#x3D; null) &#123;</span><br><span class="line">          &#x2F;&#x2F; 如果在配置文件中type&#x3D;POOLED，代表使用连接池，close会将连接放回连接池中</span><br><span class="line">          &#x2F;&#x2F; 如果type&#x3D;UNPOOLED，代表直连，close则会调用Connection.close()方法关闭连接</span><br><span class="line">          sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="mybatisutils初始化工具类"><a class="markdownIt-Anchor" href="#mybatisutils初始化工具类"></a> MyBatisUtils初始化工具类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; MyBatis工具类，利用创建全局唯一的SqlSessionFactory对象</span><br><span class="line">public class MyBatisUtils &#123;</span><br><span class="line">  &#x2F;&#x2F; static变量属于类而不属于对象，以保证全局唯一</span><br><span class="line">  private static SqlSessionFactory sqlSessionFactory &#x3D; null;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 在类的初始化过程中创建SqlSessionFactory</span><br><span class="line">  static &#123;</span><br><span class="line">    Reader reader &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      reader &#x3D; Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;);</span><br><span class="line">      sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(reader);</span><br><span class="line"></span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      throw new ExceptionInInitializerError(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 工具类的方法一般可以标注为static</span><br><span class="line">  public static SqlSession openSession() &#123;</span><br><span class="line">    return sqlSessionFactory.openSession();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void closeSession(SqlSession session) &#123;</span><br><span class="line">    if (session !&#x3D; null) &#123;</span><br><span class="line">      session.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mybatis数据查询"><a class="markdownIt-Anchor" href="#mybatis数据查询"></a> MyBatis数据查询</h2><ol><li>创建实体类（entity）</li><li>创建Mapper XML</li><li>编写select SQL标签</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace&#x3D;&quot;goods&quot;&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;selectAll&quot; resultType&#x3D;&quot;entity.Goods&quot;&gt;</span><br><span class="line">        select * from t_goods order by goods_id desc limit 10;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>开启驼峰命名映射</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;!-- goods_id &#x3D;&gt; goodsId 命名转换 --&gt;</span><br><span class="line">    &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>新增<code>&lt;mapper&gt;</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource&#x3D;&quot;mappers&#x2F;goods.xml&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mappers&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li>SqlSession执行sql语句</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Goods&gt; list &#x3D; session.selectList(&quot;goods.selectAll&quot;);</span><br></pre></td></tr></table></figure><h2 id="sql传参"><a class="markdownIt-Anchor" href="#sql传参"></a> SQL传参</h2><ul><li>使用parameterType=”Integer“</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectById&quot; parameterType&#x3D;&quot;Integer&quot; resultType&#x3D;&quot;entity.Goods&quot;&gt;</span><br><span class="line">    select * from t_goods where goods_id &#x3D; #&#123;value&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><h3 id="多参数"><a class="markdownIt-Anchor" href="#多参数"></a> 多参数</h3><ul><li>使用Map数据结构传入多个参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectByPriceRange&quot; parameterType&#x3D;&quot;java.util.Map&quot; resultType&#x3D;&quot;entity.Goods&quot;&gt;</span><br><span class="line">    select * from t_goods where current_price between #&#123;min&#125; and #&#123;max&#125;</span><br><span class="line">    order by current_price</span><br><span class="line">    limit 0, #&#123;limt&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><h2 id="多表关联查询"><a class="markdownIt-Anchor" href="#多表关联查询"></a> 多表关联查询</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;软件开发中的框架&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#软件开发中的框架&quot;&gt;&lt;/a&gt; 软件开发中的框架&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;框架是可被应用开发者定制的应用骨架&lt;/li&gt;
&lt;li&gt;框架是一种规则，保证开发者遵循相同的方式开</summary>
      
    
    
    
    
    <category term="MyBatis" scheme="http://hellcy.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Java Lambda and Stream</title>
    <link href="http://hellcy.github.io/2022/02/20/Java-Lambda-and-Stream/"/>
    <id>http://hellcy.github.io/2022/02/20/Java-Lambda-and-Stream/</id>
    <published>2022-02-20T11:34:12.000Z</published>
    <updated>2022-02-20T13:08:24.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是lambda表达式"><a class="markdownIt-Anchor" href="#什么是lambda表达式"></a> 什么是Lambda表达式</h1><ul><li>利用Lambda可以更简洁的实现匿名内部类与函数声明与调用</li><li>基于Lambda提供stream流式处理极大简化对集合的操作</li></ul><h1 id="使用lambda表达式"><a class="markdownIt-Anchor" href="#使用lambda表达式"></a> 使用Lambda表达式</h1><ul><li><code>Collections.sort(names, (a, b) -&gt; a.compareTo(b));</code></li></ul><h1 id="lambda语法格式"><a class="markdownIt-Anchor" href="#lambda语法格式"></a> Lambda语法格式</h1><ul><li>（参数列表）-&gt; 实现语句</li><li>参数列表: 使用逗号分隔参数， 参数类型可省略，单参数的情况下括号可省略</li><li>实现语句: 单行直接写，多行用{}包括</li><li>约束条件，Lambda表达式只能实现有且只有一个抽象方法的接口，Java称为函数式接口</li></ul><h1 id="函数式编程"><a class="markdownIt-Anchor" href="#函数式编程"></a> 函数式编程</h1><ul><li>基于函数式接口并使用Lambda表达式的编程方式</li><li>函数式编程的理念是将代码作为可重用数据带入到程序运行中</li><li>强调<code>你想做什么</code>，而不是<code>你想怎么做</code></li></ul><h1 id="函数是接口"><a class="markdownIt-Anchor" href="#函数是接口"></a> 函数是接口</h1><ul><li>函数式接口是有且只有一个抽象方法的接口</li><li>Java中拥有大量函数式接口，如<code>java.lang.Runnable</code></li><li>JDK8后提供了一系列新的函数式接口，位于<code>java.util.function</code></li></ul><h2 id="函数式接口predicate"><a class="markdownIt-Anchor" href="#函数式接口predicate"></a> 函数式接口Predicate</h2><ul><li><p>用于测试传入的数据是否满足判断要求</p></li><li><p>Predicate是新增的函数式接口</p></li><li><p>需要实现test()方法进行逻辑判断</p></li><li><p>我们将函数的实现以参数形式传入</p></li><li><p>当调用<code>predicate.test()</code>时，运行的是我们传入的具体实现</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void filter(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123;</span><br><span class="line">    for (Integer num : list) &#123;</span><br><span class="line">        if (predicate.test(num)) &#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter(list, n-&gt;n%2 &#x3D;&#x3D; 1);</span><br></pre></td></tr></table></figure><h2 id="函数式接口consumer"><a class="markdownIt-Anchor" href="#函数式接口consumer"></a> 函数式接口Consumer</h2><ul><li>接受一个参数并对其加工，不返回任何结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ConsumerSample &#123;</span><br><span class="line">  &#x2F;&#x2F; output() 函数并不知道consumer.accept()函数的具体实现是什么</span><br><span class="line">  &#x2F;&#x2F; 它是多变的，具体取决于调用output时传入的参数</span><br><span class="line">  public static void output(String text, Consumer&lt;String&gt; consumer) &#123;</span><br><span class="line">    consumer.accept(text);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    String text &#x3D; &quot;some text&quot;;</span><br><span class="line">    &#x2F;&#x2F; print to console</span><br><span class="line">    output(text, s -&gt; System.out.println(&quot;print to console: &quot; + s));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; send to website</span><br><span class="line">    output(text, s -&gt; System.out.println(&quot;send to website: &quot; + s));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数式接口function"><a class="markdownIt-Anchor" href="#函数式接口function"></a> 函数式接口Function</h2><ul><li>接受一个输入参数，并且返回一个结果</li><li><code>Function&lt;T, R&gt;</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class FunctionSample &#123;</span><br><span class="line">  &#x2F;&#x2F; generate fixed length random string</span><br><span class="line">  &#x2F;&#x2F; input parameter: the length of the random string</span><br><span class="line">  &#x2F;&#x2F; return: random string</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Function&lt;Integer, String&gt; randomStringFunction &#x3D; l -&gt; &#123;</span><br><span class="line">      String chars &#x3D; &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;;</span><br><span class="line">      StringBuffer stringBuffer &#x3D; new StringBuffer();</span><br><span class="line">      Random random &#x3D; new Random();</span><br><span class="line">      for (int i &#x3D; 0; i &lt; l; ++i) &#123;</span><br><span class="line">        int position &#x3D; random.nextInt(chars.length());</span><br><span class="line">        stringBuffer.append(chars.charAt(position));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return stringBuffer.toString();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(randomStringFunction.apply(10));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数式编程特点"><a class="markdownIt-Anchor" href="#函数式编程特点"></a> 函数式编程特点</h1><ul><li>面向过程</li><li>侧重结果，快速实现</li><li>更适合人眼阅读</li><li>代码量少</li><li>不会出现线程安全问题，每一个函数都是独一的</li><li>健壮性差</li><li>适合小型应用，要求快速实现</li></ul><h1 id="stream流式处理"><a class="markdownIt-Anchor" href="#stream流式处理"></a> Stream流式处理</h1><ul><li>建立在Lambda基础上的多数据处理技术</li><li>对集合数据处理进行高度抽象。极大简化代码量</li><li>可对集合进行迭代，筛选，排序，聚合等一系列处理</li></ul><h2 id="stream实例"><a class="markdownIt-Anchor" href="#stream实例"></a> Stream实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取List集合中最大的偶数</span><br><span class="line">Optional&lt;Integer&gt; op &#x3D; Arrays.asList(1,2,3,4,5,6).stream()</span><br><span class="line">  .filter(x -&gt; x % 2 &#x3D;&#x3D; 0) &#x2F;&#x2F; get even numbers</span><br><span class="line">  .sorted((a, b) -&gt; b - a) &#x2F;&#x2F; sort descending</span><br><span class="line">  .findFirst(); &#x2F;&#x2F; get first element</span><br><span class="line"></span><br><span class="line">System.out.println(op.get());</span><br></pre></td></tr></table></figure><h2 id="stream常用方法"><a class="markdownIt-Anchor" href="#stream常用方法"></a> Stream常用方法</h2><table><thead><tr><th>接口</th><th>用途</th></tr></thead><tbody><tr><td>forEach</td><td>循环遍历</td></tr><tr><td>map</td><td>map方法用于映射每个元素到对应的结果</td></tr><tr><td>filter</td><td>filter方法用于通过设置的条件过滤出元素</td></tr><tr><td>limit</td><td>用于获取指定元素数量</td></tr><tr><td>sorted</td><td>用于对流进行排序</td></tr><tr><td>Collectors</td><td>Collectors类实现将流转换成集合和聚合元素</td></tr></tbody></table><h2 id="创建流的5中方式"><a class="markdownIt-Anchor" href="#创建流的5中方式"></a> 创建流的5中方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Stream流对象创建的5种方式</span><br><span class="line">public class StreamGenerator &#123;</span><br><span class="line">  &#x2F;&#x2F; 基于数组创建</span><br><span class="line">  @Test</span><br><span class="line">  public void generatorOne() &#123;</span><br><span class="line">    String[] strings &#x3D; &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;&#125;;</span><br><span class="line">    Stream&lt;String&gt; stream &#x3D; Stream.of(strings);</span><br><span class="line">    stream.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 基于集合创建</span><br><span class="line">  @Test</span><br><span class="line">  public void generatorTwo() &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    list.add(&quot;one&quot;);</span><br><span class="line">    list.add(&quot;two&quot;);</span><br><span class="line">    list.add(&quot;three&quot;);</span><br><span class="line">    list.add(&quot;four&quot;);</span><br><span class="line">    list.stream().forEach(s -&gt; System.out.println(s));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 基于generate方法创建无限长度流</span><br><span class="line">  @Test</span><br><span class="line">  public void generatorThree() &#123;</span><br><span class="line">    Stream&lt;Integer&gt; stream &#x3D; Stream.generate(() -&gt; new Random().nextInt(100000));</span><br><span class="line">    stream.limit(10).forEach(i -&gt; System.out.println(i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 基于迭代器创建流</span><br><span class="line">  &#x2F;&#x2F; 可以替代for循环，但是使用较少</span><br><span class="line">  @Test</span><br><span class="line">  public void generatorFour() &#123;</span><br><span class="line">    Stream&lt;Integer&gt; stream &#x3D; Stream.iterate(1, n -&gt; n + 1);</span><br><span class="line">    stream.limit(100).forEach(i -&gt; System.out.println(i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 基于字符序列创建流</span><br><span class="line">  @Test</span><br><span class="line">  public void generatorFive() &#123;</span><br><span class="line">    String str &#x3D; &quot;some text&quot;;</span><br><span class="line">    IntStream stream &#x3D; str.chars();</span><br><span class="line">    stream.forEach(c -&gt; System.out.println((char) c));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tips-about-intstream-and-streaminteger"><a class="markdownIt-Anchor" href="#tips-about-intstream-and-streaminteger"></a> Tips about IntStream and Stream<Integer></h2><ul><li>IntStream contains the stream of primitive type values</li><li><code>Stream&lt;Integer&gt;</code> box the values to Integer</li><li>if you want to convert strings to primitive type you could use mapToInt() instead of just map(), this will give you primitive values and can be assigned to IntStream</li></ul><h3 id="examples"><a class="markdownIt-Anchor" href="#examples"></a> Examples</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; List of Strings to IntStream</span><br><span class="line">List&lt;String&gt; list &#x3D;  Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);</span><br><span class="line">IntStream stream &#x3D; list.stream()</span><br><span class="line">        .mapToInt(s -&gt; Integer.parseInt(s));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; List of Strings to Stream&lt;Integer&gt;</span><br><span class="line">List&lt;String&gt; list &#x3D;  Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);</span><br><span class="line">Stream&lt;Integer&gt; stream &#x3D; list.stream()</span><br><span class="line">        .map(s -&gt; Integer.parseInt(s));</span><br></pre></td></tr></table></figure><h2 id="更多案例"><a class="markdownIt-Anchor" href="#更多案例"></a> 更多案例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class StreamMethod &#123;</span><br><span class="line">  &#x2F;&#x2F; 提取集合中所有偶数并求和</span><br><span class="line">  @Test</span><br><span class="line">  public void methodOne() &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D;  Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);</span><br><span class="line">    int sum &#x3D; list.stream()</span><br><span class="line">            .mapToInt(s -&gt; Integer.parseInt(s)) &#x2F;&#x2F; convert element from string to int</span><br><span class="line">            .filter(n -&gt; n % 2 &#x3D;&#x3D; 0) &#x2F;&#x2F; get all even numbers</span><br><span class="line">            .sum(); &#x2F;&#x2F; sum to one int</span><br><span class="line"></span><br><span class="line">    System.out.println(sum);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 所有名字首字母大写</span><br><span class="line">  @Test</span><br><span class="line">  public void methodTwo() &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(&quot;lily&quot;, &quot;smith&quot;, &quot;jackson&quot;);</span><br><span class="line">    List&lt;String&gt; newList &#x3D; list.stream()</span><br><span class="line">            .map(s -&gt; s.substring(0, 1).toUpperCase() + s.substring(1)) &#x2F;&#x2F; 按指定规则对每一个流数据进行转换</span><br><span class="line">            .collect(Collectors.toList()); &#x2F;&#x2F; 对流数据进行收集，生成新的List&#x2F;Set</span><br><span class="line"></span><br><span class="line">    System.out.println(newList);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 将所有奇数从大到小排序，且不许出现重复</span><br><span class="line">  @Test</span><br><span class="line">  public void methodThree() &#123;</span><br><span class="line">    List&lt;Integer&gt; list &#x3D; Arrays.asList(1,69,342,4,5,143,2134,5,4324,45,56);</span><br><span class="line">    List&lt;Integer&gt; newList &#x3D; list.stream().distinct() &#x2F;&#x2F; 去除重复的数据</span><br><span class="line">            .filter(n -&gt; n % 2 &#x3D;&#x3D; 1) &#x2F;&#x2F; 拿到奇数</span><br><span class="line">            .sorted((a, b) -&gt; b - a) &#x2F;&#x2F; 排序</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    System.out.println(newList);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是lambda表达式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是lambda表达式&quot;&gt;&lt;/a&gt; 什么是Lambda表达式&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;利用Lambda可以更简洁的实现匿名内部类与函数声明与调用&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
    <category term="Java" scheme="http://hellcy.github.io/tags/Java/"/>
    
    <category term="Lambda" scheme="http://hellcy.github.io/tags/Lambda/"/>
    
    <category term="Stream" scheme="http://hellcy.github.io/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>Java Reflection</title>
    <link href="http://hellcy.github.io/2022/02/20/Java-Reflection/"/>
    <id>http://hellcy.github.io/2022/02/20/Java-Reflection/</id>
    <published>2022-02-20T05:27:27.000Z</published>
    <updated>2022-02-20T07:28:58.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是java反射"><a class="markdownIt-Anchor" href="#什么是java反射"></a> 什么是Java反射</h1><ul><li>反射reflection是在运行时动态访问类与对象的技术</li><li>反射是JDK1.2版本后的高级特性，隶属于<code>java.lang.reflect</code></li><li>他将对象的创建时机从原本的编译时创建延迟到运行时创建</li><li>大多数Java框架都基于反射实现参数配置，动态注入等特性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;please enter math operation&quot;);</span><br><span class="line">String op &#x3D; in.next();</span><br><span class="line">System.out.println(&quot;please enter first number&quot;);</span><br><span class="line">int a &#x3D; in.nextInt();</span><br><span class="line">System.out.println(&quot;please enter second number&quot;);</span><br><span class="line">int b &#x3D; in.nextInt();</span><br><span class="line">MathOperation operation &#x3D; null;</span><br><span class="line"></span><br><span class="line">operation &#x3D; (MathOperation) Class.forName(op).getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure><h1 id="反射的核心类"><a class="markdownIt-Anchor" href="#反射的核心类"></a> 反射的核心类</h1><ul><li>Class</li><li>Constructor</li><li>Method</li><li>Field</li></ul><h1 id="class类"><a class="markdownIt-Anchor" href="#class类"></a> Class类</h1><ul><li>Class是JVM中代表<code>类和接口</code>的类</li><li>Class对象具体包含了某个特定类的结构信息</li><li>通过Class类可以获取对应类的构造方法，方法，成员变量</li></ul><h2 id="class核心方法"><a class="markdownIt-Anchor" href="#class核心方法"></a> Class核心方法</h2><ul><li>Class.forName() - 静态方法，用于获取指定Class对象</li><li>classObj.newInstance() - 通过默认构造方法创建新的对象 （在Java9之后被deprecated）</li><li>classObj.getConstructor() - 获取指定的public修饰构造方法Constructor对象</li><li>classObj.getMethod() - 获取指定的public修饰方法Method对象</li><li>classObj.getField() - 获取指定的public修饰的成员变量Field对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将Employee类加载到JVM，并返回对应Class对象</span><br><span class="line">Class employeeClass &#x3D; Class.forName(&quot;entity.Employee&quot;);</span><br><span class="line">System.out.println(&quot;Employee has been loaded to JVM&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; newInstance 调用默认构造方法创建新对象</span><br><span class="line">Employee emp &#x3D; (Employee) employeeClass.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure><h2 id="创建class对象时可能抛出的异常"><a class="markdownIt-Anchor" href="#创建class对象时可能抛出的异常"></a> 创建Class对象时可能抛出的异常</h2><ul><li>InstantiationException<ul><li>实例化异常，对象无法被实例化</li><li>例如abstract抽象对象</li></ul></li><li>IllegalAccessException<ul><li>非法访问，在作用域外访问对象构造方法或成员变量</li><li>例如尝试访问私有构造方法</li></ul></li></ul><h1 id="constructor类"><a class="markdownIt-Anchor" href="#constructor类"></a> Constructor类</h1><ul><li>对Java类中的构造方法的抽象</li><li>Constructor对象包含了具体类的某个具体构造方法的声明</li><li>通过Constructor对象调用带参构造方法创建对象</li></ul><h2 id="constructor类的核心方法"><a class="markdownIt-Anchor" href="#constructor类的核心方法"></a> Constructor类的核心方法</h2><ul><li><p>classObj.getConstructor() - 获取指定public修饰的构造方法对象</p></li><li><p>constructorObj.newInstance() - 通过对应的构造方法创建对象</p></li><li><p>例子，在通过Class对象创建Constructor对象时，需要提供每一个参数的Class类</p></li><li><p>在Constructor对象创建Employee对象时，需要传入每一个参数</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class employeeClass &#x3D; Class.forName(&quot;entity.Employee&quot;);</span><br><span class="line">Constructor constructor &#x3D; employeeClass.getConstructor(new Class[] &#123;</span><br><span class="line">        Integer.class,</span><br><span class="line">        String.class,</span><br><span class="line">        Float.class,</span><br><span class="line">        String.class</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Employee employee &#x3D; (Employee) constructor.newInstance(new Object[] &#123;</span><br><span class="line">        100, &quot;yuan cheng&quot;, 3000f, &quot;研发部&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="创建constructor对象时可能抛出的异常"><a class="markdownIt-Anchor" href="#创建constructor对象时可能抛出的异常"></a> 创建Constructor对象时可能抛出的异常</h2><ul><li>InstantiationException<ul><li>实例化异常，对象无法被实例化</li><li>例如abstract抽象对象</li></ul></li><li>IllegalAccessException<ul><li>非法访问，在作用域外访问对象构造方法或成员变量</li><li>例如尝试访问私有构造方法</li></ul></li><li>InvocationTargetException<ul><li>当被调用的方法内部抛出了异常而没有被捕获时</li></ul></li><li>NoSuchMethodException<ul><li>没有找到与之对应的构造方法</li></ul></li></ul><h1 id="method类"><a class="markdownIt-Anchor" href="#method类"></a> Method类</h1><ul><li>Method对象指代某个类中的方法的描述</li><li>Method对象使用classObj.getMethod()方法获取</li><li>通过Method对象调用指定对象的对应方法</li></ul><h2 id="method类核心方法"><a class="markdownIt-Anchor" href="#method类核心方法"></a> Method类核心方法</h2><ul><li>classObj.getMethod() - 获取指定public修饰的方法的对象</li><li>methodObj.invoke() - 调用指定对象的对应方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class employeeClass &#x3D; Class.forName(&quot;entity.Employee&quot;);</span><br><span class="line">Constructor constructor &#x3D; employeeClass.getConstructor(new Class[] &#123;</span><br><span class="line">        Integer.class, String.class, Float.class, String.class</span><br><span class="line">&#125;);</span><br><span class="line">Employee employee &#x3D; (Employee) constructor.newInstance(new Object[] &#123;</span><br><span class="line">        100, &quot;yuan&quot;, 3000f, &quot;研发部&quot;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Method method &#x3D; employeeClass.getMethod(&quot;updateSalary&quot;, Float.class);</span><br><span class="line">Employee newEmpoyee &#x3D; (Employee) method.invoke(employee, 1000f);</span><br><span class="line">System.out.println(newEmpoyee);</span><br></pre></td></tr></table></figure><h1 id="field类"><a class="markdownIt-Anchor" href="#field类"></a> Field类</h1><ul><li>对应某个具体类中成员变量的声明</li><li>Field对象使用classObj.getField()方法获取</li><li>通过Field对象可为某对象成员变量赋值/取值</li></ul><h2 id="field类核心方法"><a class="markdownIt-Anchor" href="#field类核心方法"></a> Field类核心方法</h2><ul><li>classObj.getField() - 获取指定public修饰的成员变量对象</li><li>fieldObj.set() - 为某对象指定成员变量赋值</li><li>fieldObj.get() - 获取某对象指定成员变量数值</li></ul><h2 id="field可能抛出的异常"><a class="markdownIt-Anchor" href="#field可能抛出的异常"></a> Field可能抛出的异常</h2><ul><li>NoSuchFieldException<ul><li>没有找到对应的Field</li><li>当尝试访问private的Field时也会抛出这个异常</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class employeeClass &#x3D; Class.forName(&quot;entity.Employee&quot;);</span><br><span class="line">Constructor constructor &#x3D; employeeClass.getConstructor(new Class[] &#123;</span><br><span class="line">        Integer.class, String.class, Float.class, String.class</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Employee employee &#x3D; (Employee) constructor.newInstance(new Object[] &#123;</span><br><span class="line">        100, &quot;Yuan&quot;, 4000f, &quot;研发部&quot;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Field enameField &#x3D; employeeClass.getField(&quot;ename&quot;);</span><br><span class="line">String ename &#x3D; (String) enameField.get(employee);</span><br><span class="line">System.out.println(ename);</span><br><span class="line"></span><br><span class="line">enameField.set(employee, &quot;new yuan&quot;);</span><br><span class="line">System.out.println(employee);</span><br></pre></td></tr></table></figure><h1 id="getdeclared-系列方法"><a class="markdownIt-Anchor" href="#getdeclared-系列方法"></a> getDeclared。。。系列方法</h1><ul><li>之前的方法只能获取public对象</li><li>getDeclared。。系列方法可以获取非作用域内的构造方法，方法，成员变量 （private）</li></ul><h2 id="例子如果我们想获取当前对象的所有成员变量的值"><a class="markdownIt-Anchor" href="#例子如果我们想获取当前对象的所有成员变量的值"></a> 例子，如果我们想获取当前对象的所有成员变量的值</h2><ul><li>不管是private还是public，我们需要用到getDeclaredFields()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Class employeeClass &#x3D; Class.forName(&quot;entity.Employee&quot;);</span><br><span class="line">Constructor constructor &#x3D; employeeClass.getConstructor(new Class[] &#123;</span><br><span class="line">        Integer.class, String.class, Float.class, String.class</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Employee employee &#x3D; (Employee) constructor.newInstance(new Object[] &#123;</span><br><span class="line">        100, &quot;Yuan&quot;, 4000f, &quot;研发部&quot;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取当前类所有成员变量 private + public</span><br><span class="line">Field[] fields &#x3D; employeeClass.getDeclaredFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">    if (field.getModifiers() &#x3D;&#x3D; Modifier.PUBLIC) &#123;</span><br><span class="line">        &#x2F;&#x2F; public fields</span><br><span class="line">        Object val &#x3D; field.get(employee);</span><br><span class="line">        System.out.println(field.getName() + &quot;: &quot; + val);</span><br><span class="line">    &#125; else if (field.getModifiers() &#x3D;&#x3D; Modifier.PRIVATE) &#123;</span><br><span class="line">        &#x2F;&#x2F; private fields</span><br><span class="line">        String methodName &#x3D; &quot;get&quot; + field.getName().substring(0, 1).toUpperCase()</span><br><span class="line">                + field.getName().substring(1);</span><br><span class="line">        Method getMethod &#x3D; employeeClass.getMethod(methodName);</span><br><span class="line">        Object ret &#x3D; getMethod.invoke(employee);</span><br><span class="line">        System.out.println(field.getName() + &quot;: &quot; + ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="反射在项目中的应用"><a class="markdownIt-Anchor" href="#反射在项目中的应用"></a> 反射在项目中的应用</h1><ul><li>切换网站的语言</li><li>根据不用的设备切换网站layout</li><li>不需要重新编译或者改变已有代码</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是java反射&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是java反射&quot;&gt;&lt;/a&gt; 什么是Java反射&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;反射reflection是在运行时动态访问类与对象的技术&lt;/li&gt;
&lt;li&gt;反射是JDK1</summary>
      
    
    
    
    
    <category term="Java" scheme="http://hellcy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Factory Design Pattern</title>
    <link href="http://hellcy.github.io/2022/02/20/Factory-Design-Pattern/"/>
    <id>http://hellcy.github.io/2022/02/20/Factory-Design-Pattern/</id>
    <published>2022-02-20T04:52:51.000Z</published>
    <updated>2022-02-20T05:26:28.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a class="markdownIt-Anchor" href="#设计模式"></a> 设计模式</h1><ul><li>前辈总结的设计经验</li><li>使代码更容易理解，更容易维护</li><li>让代码更加可靠</li></ul><h1 id="设计模式的分类"><a class="markdownIt-Anchor" href="#设计模式的分类"></a> 设计模式的分类</h1><ul><li>创建型模式<ul><li>帮助我们更加精巧的创建对象</li></ul></li><li>结构性模式<ul><li>重构，抽象，是代码更容易维护和扩展</li></ul></li><li>行为型模式<ul><li>针对现实中的具体场景进行优化</li></ul></li></ul><h1 id="工厂模式"><a class="markdownIt-Anchor" href="#工厂模式"></a> 工厂模式</h1><ul><li>用于隐藏创建对象的细节</li><li>核心： 工厂类，帮助我们创建具体对象</li><li>工厂模式可细分为<ul><li>简单工厂</li><li>工厂方法</li><li>抽象工厂</li></ul></li></ul><p><img src="/images/Factory-Design-Pattern/1.png" alt="" /></p><ul><li><p>所有的对象都实现同一个接口</p></li><li><p>工厂类负责判断具体创建那个对象，并返回相应的接口</p></li><li><p>用户只需要传入参数告诉工厂类，工厂类负责根据传入的参数判断具体创建那个对象</p></li><li><p>对象以接口的形式返回给用户，用户不需要知道具体创建了那个类的对象</p></li><li><p>用户类</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">I18N i18N &#x3D; I18NFactory.getI18NObject(&quot;china&quot;);</span><br><span class="line">Device device &#x3D; DeviceFactory.getDeviceObject(&quot;mobile&quot;);</span><br><span class="line">System.out.println(device.getHomePage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>工厂类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class DeviceFactory &#123;</span><br><span class="line">  &#x2F;&#x2F; 静态工厂，创建具体对象的方法是静态的</span><br><span class="line">  &#x2F;&#x2F; 在调用时不需要实例化工厂</span><br><span class="line">  public static Device getDeviceObject(String userAgent) &#123;</span><br><span class="line">    if (userAgent.equals(&quot;mobile&quot;)) &#123;</span><br><span class="line">      return new MobileDevice();</span><br><span class="line">    &#125; else if (userAgent.equals(&quot;desktop&quot;)) &#123;</span><br><span class="line">      return new DesktopDevice();</span><br><span class="line">    &#125; else return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Device &#123;</span><br><span class="line">  String getHomePage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MobileDevice implements Device &#123;</span><br><span class="line">    public String getHomePage() &#123;</span><br><span class="line">        return &quot;mobile device home page&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DesktopDevice implements Device &#123;</span><br><span class="line">    public String getHomePage() &#123;</span><br><span class="line">        return &quot;Desktop device home page&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#设计模式&quot;&gt;&lt;/a&gt; 设计模式&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;前辈总结的设计经验&lt;/li&gt;
&lt;li&gt;使代码更容易理解，更容易维护&lt;/li&gt;
&lt;li&gt;让代码更加可靠&lt;/li&gt;
&lt;/ul</summary>
      
    
    
    
    
    <category term="Design Patterns" scheme="http://hellcy.github.io/tags/Design-Patterns/"/>
    
    <category term="Factory" scheme="http://hellcy.github.io/tags/Factory/"/>
    
  </entry>
  
  <entry>
    <title>Maven Basics</title>
    <link href="http://hellcy.github.io/2022/02/20/Maven-Basics/"/>
    <id>http://hellcy.github.io/2022/02/20/Maven-Basics/</id>
    <published>2022-02-20T02:34:49.000Z</published>
    <updated>2022-02-20T04:51:47.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="maven介绍"><a class="markdownIt-Anchor" href="#maven介绍"></a> Maven介绍</h1><ul><li>项目管理工具，对软件项目提供构建与依赖管理</li><li>Apache下的Java开源项目</li><li>为Java项目提供了统一的管理方式</li></ul><h1 id="maven核心特性"><a class="markdownIt-Anchor" href="#maven核心特性"></a> Maven核心特性</h1><ul><li>项目设置遵循统一的规则，保证不同开发环境的兼容性 （Eclipse， IDEA， NetBeans）</li><li>强大的依赖管理，项目依赖组件自动下载，自动更新（JARs，dependencies）</li><li>Maven中央仓库</li><li>可扩展的插件机制，使用简单，功能丰富 （自定义的插件可以加入到Maven中）</li></ul><h1 id="maven的坐标"><a class="markdownIt-Anchor" href="#maven的坐标"></a> Maven的坐标</h1><ul><li>GroupId：机构或者团体的英文，采用逆向域名的形式书写</li><li>ArtifactId：项目名称，说明其用途，例如：cms， oa</li><li>Version：版本号，一般采用版本 + 单词 形式书写 例如： 1.0.0.RELEASE</li></ul><h1 id="maven项目标准结构"><a class="markdownIt-Anchor" href="#maven项目标准结构"></a> Maven项目标准结构</h1><table><thead><tr><th>目录</th><th>用途</th></tr></thead><tbody><tr><td>root</td><td>根目录，用于保存pom.xml</td></tr><tr><td>main/java</td><td>Java源代码目录</td></tr><tr><td>main/resources</td><td>资源目录，保存配置文件，静态图片等</td></tr><tr><td>test/java</td><td>测试类的源代码</td></tr><tr><td>test/resources</td><td>测试时需要使用的资源文件</td></tr><tr><td>target</td><td>项目输出的目录，用于储存jar，war文件</td></tr><tr><td>target/classes</td><td>字节码的编译输出目录</td></tr><tr><td>pom.xml</td><td>项目对象模型文件（Project，Object，Model）</td></tr></tbody></table><h1 id="maven依赖管理"><a class="markdownIt-Anchor" href="#maven依赖管理"></a> Maven依赖管理</h1><ul><li>利用dependency自动下载，管理第三方JAR</li><li>在pom.xml文件中配置项目依赖的第三方组件</li><li>Maven自动将依赖从远程仓库（中央仓库）下载至本地仓库，并在工程中引用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.1.47&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><ul><li>Maven会自动下载JAR所依赖的其他JAR</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.3.16&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>例如spring-webmvc依赖很多其他JAR，但当你引用spring-webmvc时，你无需管理其他依赖，Maven会自动管理并下载其他所需的依赖</li></ul><h1 id="本地仓库与中央仓库"><a class="markdownIt-Anchor" href="#本地仓库与中央仓库"></a> 本地仓库与中央仓库</h1><p><img src="/images/Maven-Basics/1.png" alt="" /><br /><img src="/images/Maven-Basics/2.png" alt="" /></p><h1 id="项目打包"><a class="markdownIt-Anchor" href="#项目打包"></a> 项目打包</h1><ul><li>Maven可将Java项目打包为JAR，WAR</li><li>项目打包是通过Plugin实现</li><li>Maven输出JAR包插件： <code>maven-assembly-plugin</code></li><li>运行JAR in Terminal<ul><li><code>java -jar jav_name</code></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;maven介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#maven介绍&quot;&gt;&lt;/a&gt; Maven介绍&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;项目管理工具，对软件项目提供构建与依赖管理&lt;/li&gt;
&lt;li&gt;Apache下的Java开源项目&lt;/li</summary>
      
    
    
    
    
    <category term="Java" scheme="http://hellcy.github.io/tags/Java/"/>
    
    <category term="Maven" scheme="http://hellcy.github.io/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>JDBC Basics</title>
    <link href="http://hellcy.github.io/2022/02/17/JDBC-Basics/"/>
    <id>http://hellcy.github.io/2022/02/17/JDBC-Basics/</id>
    <published>2022-02-17T11:51:57.000Z</published>
    <updated>2022-02-20T02:33:42.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是jdbc"><a class="markdownIt-Anchor" href="#什么是jdbc"></a> 什么是JDBC</h1><ul><li><code>Java Database Connectivity</code></li><li>让Java程序操作关系型数据库</li><li>JDBC基于驱动程序实现与数据库的连接与操作</li><li>驱动程序实现了JDBC API，所以Java程序可以调用JABC API（也就是调用底层的MySQL驱动程序的实现）来对数据库进行访问</li></ul><h1 id="jdbc的优点"><a class="markdownIt-Anchor" href="#jdbc的优点"></a> JDBC的优点</h1><ul><li>统一的API，提供一指的开发过程</li><li>易于学习，容易上手，代码结构稳定</li><li>功能强大，执行效率高，可处理大量数据</li></ul><h1 id="jdbc开发流程"><a class="markdownIt-Anchor" href="#jdbc开发流程"></a> JDBC开发流程</h1><ol><li>加载并注册JDBC驱动</li><li>创建数据库链接</li><li>创建Statement对象</li><li>遍历查询结果</li><li>关闭链接，释放资源</li></ol><h2 id="classforname的作用"><a class="markdownIt-Anchor" href="#classforname的作用"></a> Class.forName的作用</h2><ul><li>用于加载指定的JDBC驱动类</li><li>本质是通知JDBC注册这个驱动类</li></ul><h2 id="drivermanager"><a class="markdownIt-Anchor" href="#drivermanager"></a> DriverManager</h2><ul><li>用于注册，管理JDBC驱动程序</li><li><code>DriverManager.getConnection()</code></li><li>返回值Connection对象，对应数据库的物理网络连接</li></ul><h2 id="connection对象"><a class="markdownIt-Anchor" href="#connection对象"></a> Connection对象</h2><ul><li>Connection对象用于JDBC与数据库的网络通信对象</li><li><code>java.sql.Connection</code>是一个接口，具体实现由驱动厂商负责</li><li>所有数据库的操作都建立在Connection基础上</li></ul><h2 id="链接字符串"><a class="markdownIt-Anchor" href="#链接字符串"></a> 链接字符串</h2><ul><li><code>jdbc:mysql://localhost:port_number/database_name</code></li><li>之后可以添加额外参数</li><li>参数列表采用URL格式：name=value&amp;name2=value2&amp;…</li></ul><h3 id="mysql连接字符串常用参数"><a class="markdownIt-Anchor" href="#mysql连接字符串常用参数"></a> MySQL连接字符串常用参数</h3><table><thead><tr><th>参数名</th><th>建议参数值</th><th>说明</th></tr></thead><tbody><tr><td>useSSL</td><td>true/false</td><td>是否禁用SSL</td></tr><tr><td>useUnicode</td><td>true</td><td>启用unicode编码传输数据</td></tr><tr><td>characterEncoding</td><td>UTF-8</td><td>使用UTF-8编码</td></tr><tr><td>serverTimezone</td><td>Australia/Sydney</td><td>timezone</td></tr><tr><td>allowPublicKeyRetrieval</td><td>true</td><td>允许从客户端获取公钥加密传输</td></tr></tbody></table><ul><li>如果数据库的设置已经是使用澳洲时区，那么连接字符串的参数可以省略</li></ul><h2 id="sql注入攻击"><a class="markdownIt-Anchor" href="#sql注入攻击"></a> SQL注入攻击</h2><ul><li><code>'</code>单引号没有被特殊处理，被当成SQL query的一部分</li><li>利用SQL漏洞越权获取数据的黑客行为</li><li>根源是未对原始SQL中的敏感字符做特殊处理 （转译escape）</li><li>解决方法：放弃Statement改用PreparedStatement处理SQL</li></ul><h3 id="preparestatement"><a class="markdownIt-Anchor" href="#preparestatement"></a> PrepareStatement</h3><ul><li>是Statement的子接口</li><li>对SQL进行参数化，预防SQL注入攻击</li><li>比Statement执行效率更好</li></ul><h3 id="错误的使用方式"><a class="markdownIt-Anchor" href="#错误的使用方式"></a> 错误的使用方式</h3><ul><li><code>select * from employee where ? = 'abc';</code></li><li><code>select * from employee where salary = ? + 100;</code></li><li><code>select * from employee where ename = ?;</code></li></ul><h2 id="封装数据库连接"><a class="markdownIt-Anchor" href="#封装数据库连接"></a> 封装数据库连接</h2><ul><li>每次对数据库操作时都需要打开和关闭，我们可以将这个重复的步骤封装到一个Class中，需要时直接调用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 封装数据库链接</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class DbUtils &#123;</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 创建新的数据库链接</span><br><span class="line">   * @return 新的Connection对象</span><br><span class="line">   * @throws SQLException</span><br><span class="line">   * @throws ClassNotFoundException</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public static Connection getConnection() throws SQLException, ClassNotFoundException &#123;</span><br><span class="line">    &#x2F;&#x2F;1. 加载并注册JDBC驱动</span><br><span class="line">    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2. 创建数据库链接</span><br><span class="line">    Connection conn &#x3D; DriverManager.getConnection(</span><br><span class="line">            &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;imooc?useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;Australia&#x2F;Sydney&quot;,</span><br><span class="line">            &quot;yuan&quot;,</span><br><span class="line">            &quot;1111&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return conn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 关闭链接，释放资源</span><br><span class="line">   * @param rs 结果集对象</span><br><span class="line">   * @param statement Statement对象</span><br><span class="line">   * @param conn Connection对象</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public static void closeConnection(ResultSet rs, Statement statement, Connection conn) &#123;</span><br><span class="line">    &#x2F;&#x2F; 5. 关闭链接，释放资源</span><br><span class="line">    try &#123;</span><br><span class="line">      if (rs !&#x3D; null) conn.close();</span><br><span class="line">      if (statement !&#x3D; null) statement.close();</span><br><span class="line">      if (conn !&#x3D; null &amp;&amp; !conn.isClosed()) conn.close();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jdbc执行insert-update-delete语句"><a class="markdownIt-Anchor" href="#jdbc执行insert-update-delete语句"></a> JDBC执行INSERT, UPDATE, DELETE语句</h2><ul><li>statement.executeUpdate()</li><li>返回受影响得行数</li></ul><h2 id="jdbc事务管理"><a class="markdownIt-Anchor" href="#jdbc事务管理"></a> JDBC事务管理</h2><ul><li>事务依赖于数据库的实现，MySQL通过事务区作为数据缓冲地带</li><li>全部成功或者全部失败</li></ul><h3 id="自动提交事务模式"><a class="markdownIt-Anchor" href="#自动提交事务模式"></a> 自动提交事务模式</h3><ul><li>没执行一次写操作SQL，自动提交事务</li><li><code>conn.setAutoCommit(true)</code></li><li>默认的事务模式</li><li>无法保证多数据一致性</li></ul><h3 id="手动提交事务模式"><a class="markdownIt-Anchor" href="#手动提交事务模式"></a> 手动提交事务模式</h3><ul><li>显示调用<code>commit()</code>与<code>rollback()</code>方法管理事务</li><li><code>conn.setAutoCommit(false)</code></li><li>可保证数据一致性，但必须手动调用提交、回滚方法</li></ul><h2 id="jdbc中date日期对象的处理"><a class="markdownIt-Anchor" href="#jdbc中date日期对象的处理"></a> JDBC中Date日期对象的处理</h2><ul><li>JDBC获取日期使用<code>java.sql.Date</code>,它继承自<code>java.util.Date</code></li><li>所以当获取MySQL中的日期时，两者互相兼容</li></ul><h3 id="date日期的提取"><a class="markdownIt-Anchor" href="#date日期的提取"></a> Date日期的提取</h3><ul><li>因为sql.Date继承自util.Date所以可以直接提取</li></ul><h3 id="date日期的插入"><a class="markdownIt-Anchor" href="#date日期的插入"></a> Date日期的插入</h3><ul><li>需要先将用户输入String转换成java.util.Date<ul><li><code>String -&gt; java.util.Date</code></li></ul></li><li>再将java.util.Date转换成java.sql.Date<ul><li><code>java.util.Date -&gt; java.sql.Date</code></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.string -&gt; java.util.Date</span><br><span class="line">Date udHireDate &#x3D; null;</span><br><span class="line">SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">    udHireDate &#x3D; sdf.parse(strHireDate);</span><br><span class="line">&#125; catch (ParseException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. java.util.Date -&gt; java.sql.Date</span><br><span class="line">long time &#x3D; udHireDate.getTime(); &#x2F;&#x2F; 获取自1970年到现在的毫秒数</span><br><span class="line">java.sql.Date sdHireDate &#x3D; new java.sql.Date(time);</span><br></pre></td></tr></table></figure><h2 id="jdbc批处理"><a class="markdownIt-Anchor" href="#jdbc批处理"></a> JDBC批处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String sql &#x3D; &quot;insert into employee (eno, ename, salary, dname) values (?, ?, ?, ?);&quot;;</span><br><span class="line">statement &#x3D; conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 200000; i &lt; 300000; i++) &#123;</span><br><span class="line">statement.setInt(1, i);</span><br><span class="line">statement.setString(2, &quot;员工&quot; + i);</span><br><span class="line">statement.setFloat(3, 4000);</span><br><span class="line">statement.setString(4, &quot;市场部&quot;);</span><br><span class="line">statement.addBatch(); &#x2F;&#x2F; add params to batch job, not execute yet</span><br><span class="line">&#125;</span><br><span class="line">statement.executeBatch(); &#x2F;&#x2F; execute batch job</span><br></pre></td></tr></table></figure><h2 id="连接池与jdbc进阶"><a class="markdownIt-Anchor" href="#连接池与jdbc进阶"></a> 连接池与JDBC进阶</h2><ul><li>建立数据库链接比较费时间</li><li>当我们知道应用的大概人数后，可以在应用启动时，提前创建好大概的连接并存放到连接池中</li><li>当有用户需要连接数据库时，直接从连接池中获取一个可用的连接，用完之后再放入到连接池中以供其他用户使用</li><li>管理，分配，连接</li><li>程序只负责取用和归还</li></ul><h3 id="druid连接池"><a class="markdownIt-Anchor" href="#druid连接池"></a> Druid连接池</h3><ul><li>Druid是阿里巴巴开源连接池组件</li></ul><p><img src="/images/JDBC_Basics/1.png" alt="" /></p><ul><li>连接池配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">driverClassName&#x3D;com.mysql.cj.jdbc.Driver</span><br><span class="line">url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;imooc?useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;Australia&#x2F;Sydney</span><br><span class="line">username&#x3D;yuan</span><br><span class="line">password&#x3D;1111</span><br><span class="line">initialSize&#x3D;10 &#x2F;&#x2F; 初始化时创建新链接的数量</span><br><span class="line">maxActive&#x3D;20 &#x2F;&#x2F; 连接池中最多的连接数量</span><br></pre></td></tr></table></figure><ul><li>连接的步骤</li></ul><ol><li>加载属性文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Properties properties &#x3D; new Properties();</span><br><span class="line">String propertyFilePath &#x3D; DruidSample.class.getResource(&quot;&#x2F;druid-config.properties&quot;).getPath();</span><br><span class="line">&#x2F;&#x2F; URL Space will be represented as %20</span><br><span class="line">&#x2F;&#x2F; so we need to decode it</span><br><span class="line">propertyFilePath &#x3D; new URLDecoder().decode(propertyFilePath, &quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; load propertyFile to properties object</span><br><span class="line">properties.load(new FileInputStream(propertyFilePath));</span><br></pre></td></tr></table></figure><ol start="2"><li>获取dataSource数据源对象，指代数据库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataSource &#x3D; DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">Connection conn &#x3D; dataSource.getConnection();</span><br></pre></td></tr></table></figure><ul><li>不使用连接池： conn.close()的作用是关闭连接</li><li>使用连接池： conn.close()的作用是将连接回收到连接池</li><li>当用户连接数量超过连接池设置的最大数量时，新的用户将会等待连接被其他用户关闭</li><li>Tips：可以将初始连接数量和最大连接数保持一致</li></ul><h3 id="扩展知识c3p0连接池"><a class="markdownIt-Anchor" href="#扩展知识c3p0连接池"></a> 扩展知识：C3P0连接池</h3><ul><li><a href="https://www.mchange.com/projects/c3p0/">C3P0连接池</a></li><li>C3P0会自动找到名为c3p0-config.xml的配置文件</li><li><code>DataSource dataSource = new ComboPooledDataSource();</code></li></ul><h3 id="apache-commons-dbutils"><a class="markdownIt-Anchor" href="#apache-commons-dbutils"></a> Apache Commons DBUtils</h3><ul><li>Apache提供的JDBC工具类库</li><li>它是对JDBC的简单封装，学习成本低</li><li>简化JDBC编码工作量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Properties properties &#x3D; new Properties();</span><br><span class="line">String propertyFilePath &#x3D; DBUtilsSample.class.getResource(&quot;&#x2F;druid-config.properties&quot;).getPath();</span><br><span class="line"></span><br><span class="line">propertyFilePath &#x3D; new URLDecoder().decode(propertyFilePath, &quot;UTF-8&quot;);</span><br><span class="line">properties.load(new FileInputStream(propertyFilePath));</span><br><span class="line">DataSource dataSource &#x3D; DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Commons DBUtils会自动帮助我们创建并关闭连接</span><br><span class="line">QueryRunner qr &#x3D; new QueryRunner(dataSource);</span><br><span class="line">&#x2F;&#x2F; convert ResultSet into list of employees</span><br><span class="line">List&lt;Employee&gt; list &#x3D; qr.query(&quot;select * from employee limit ?, 10;&quot;,</span><br><span class="line">        new BeanListHandler&lt;&gt;(Employee.class),</span><br><span class="line">        new Object[]&#123;10&#125; &#x2F;&#x2F; pass in the params in the SQL query</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">for (Employee emp : list) &#123;</span><br><span class="line">System.out.println(emp.getEname());</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是jdbc&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是jdbc&quot;&gt;&lt;/a&gt; 什么是JDBC&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Java Database Connectivity&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;让J</summary>
      
    
    
    
    
    <category term="Java" scheme="http://hellcy.github.io/tags/Java/"/>
    
    <category term="JDBC" scheme="http://hellcy.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Basics</title>
    <link href="http://hellcy.github.io/2022/02/16/MySQL-Basics/"/>
    <id>http://hellcy.github.io/2022/02/16/MySQL-Basics/</id>
    <published>2022-02-16T04:37:40.000Z</published>
    <updated>2022-02-17T10:10:17.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是数据库系统"><a class="markdownIt-Anchor" href="#什么是数据库系统"></a> 什么是数据库系统</h1><ul><li>DBMS是指一个能为用户提供信息服务的系统，它实现了有组织的，动态的储存大量相关数据的功能，提供了数据处理和信息资源共享的便利手段</li></ul><h1 id="关系型数据库-rdbms"><a class="markdownIt-Anchor" href="#关系型数据库-rdbms"></a> 关系型数据库 （RDBMS）</h1><ul><li>使用了关系模型的数据库系统</li><li>关系模型中，数据是分类存放的，数据之间可以有联系</li></ul><h1 id="什么是nosql数据库"><a class="markdownIt-Anchor" href="#什么是nosql数据库"></a> 什么是NoSQL数据库</h1><ul><li>NoSQL数据库指的是数据分类存放，但是数据之间没有关联关系的数据库系统</li></ul><h1 id="mysql配置文件"><a class="markdownIt-Anchor" href="#mysql配置文件"></a> MySQL配置文件</h1><ul><li>MySQL默认的root用户拥有所有权限，并且只能通过localhost登录，所以我们可以新建一个用户</li><li>我们可以使用Terminal指令 mysql -u root -p 来登录MySQL数据库</li><li>我们可以使用第三方的MySQL图形界面登录管理MySQL database<ul><li>sequel pro</li><li>DataGrip</li><li>NaviCat</li></ul></li><li>我们可以设置各种MySQL的配置，例如字符集，端口号，目录地址等等</li></ul><h1 id="sql语言分类"><a class="markdownIt-Anchor" href="#sql语言分类"></a> SQL语言分类</h1><ul><li>DML - 对数据进行操作，层删改查</li><li>DCL - 数据库控制语言，控制用户，权限，事务</li><li>DDL - definition，对逻辑库，数据表，视图，索引进行操作</li></ul><h2 id="sql语句注意事项"><a class="markdownIt-Anchor" href="#sql语句注意事项"></a> SQL语句注意事项</h2><ul><li>SQL语句不区分大小写</li><li>必须以分号结尾</li><li>语句中的空白和换行没有限制</li></ul><h2 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h2><ul><li><code># this is single line comment</code></li><li><code>/* this is multi line comments */</code></li></ul><h2 id="创建逻辑库"><a class="markdownIt-Anchor" href="#创建逻辑库"></a> 创建逻辑库</h2><ul><li>CREATE DATABASE database_name;</li><li>SHOW DATABASES;</li><li>DROP database_name;</li></ul><h2 id="创建数据表"><a class="markdownIt-Anchor" href="#创建数据表"></a> 创建数据表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">    id INT UNSIGNED PRIMARY KEY,</span><br><span class="line">    name VARCHAR(20) NOT NULL,</span><br><span class="line">    sex CHAR(1) NOT NULL,</span><br><span class="line">    birthday DATE NOT NULL,</span><br><span class="line">    tel CHAR(11) NOT NULL,</span><br><span class="line">    remark VARCHAR(200)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="数据表的其他操作"><a class="markdownIt-Anchor" href="#数据表的其他操作"></a> 数据表的其他操作</h2><ul><li>SHOW tables;</li><li>DESC student;</li><li>SHOW CREATE TABLE student;</li><li>DROP TABLE student;</li></ul><h2 id="不精确的浮点数"><a class="markdownIt-Anchor" href="#不精确的浮点数"></a> 不精确的浮点数</h2><p><img src="/images/MySQL-Basics/1.png" alt="" /></p><ul><li>所以在保存重要数字的时候要选用DECIMAL类型，它会将数字以字符串的形式保存，不会丢失精度</li></ul><h2 id="修改表结构"><a class="markdownIt-Anchor" href="#修改表结构"></a> 修改表结构</h2><ul><li>添加新字段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student </span><br><span class="line">ADD address VARCHAR(200) NOT NULL,</span><br><span class="line">ADD home_tel CHAR(11) NOT NULL;</span><br></pre></td></tr></table></figure><ul><li>修改字段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student</span><br><span class="line">MODIFY home_tel VARCHAR(20) NOT NULL;</span><br></pre></td></tr></table></figure><ul><li>修改字段名称</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student</span><br><span class="line">CHANGE address home_address VARCHAR(20) NOT NULL;</span><br></pre></td></tr></table></figure><ul><li>删除字段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student </span><br><span class="line">DROP home_address,</span><br><span class="line">DROP home_tel;</span><br></pre></td></tr></table></figure><h2 id="字段约束"><a class="markdownIt-Anchor" href="#字段约束"></a> 字段约束</h2><h3 id="数据库的范式"><a class="markdownIt-Anchor" href="#数据库的范式"></a> 数据库的范式</h3><ul><li>构造数据库必须遵循一定的规则，这种规则就是范式</li><li>目前关系数据库有6种范式，一般情况下，只满足第三范式即可</li></ul><h3 id="第一范式原子性"><a class="markdownIt-Anchor" href="#第一范式原子性"></a> 第一范式：原子性</h3><ul><li>第一范式是数据库的基本要求，不满足这一点就不是关系型数据库</li><li>数据表的每一列都是不可分割的基本数据项，同一列中不能有多个值，也不能存在重复的属性</li></ul><h3 id="第二范式唯一性"><a class="markdownIt-Anchor" href="#第二范式唯一性"></a> 第二范式：唯一性</h3><ul><li>数据表中的每条记录必须是唯一的，为了实现区分，通常要为表加上一个列用来储存唯一标识，这个唯一属性列被称作主键列</li></ul><h3 id="第三范式关联性"><a class="markdownIt-Anchor" href="#第三范式关联性"></a> 第三范式：关联性</h3><ul><li><p>每列都与主键有直接关系，不存在依赖传递</p></li><li><p>下图中爸爸是主键，但是女儿的玩具和女儿的衣服并不依赖与主键，而是依赖于女儿，所以不满足第三范式<br /><img src="/images/MySQL-Basics/2.png" alt="" /></p></li><li><p>依照第三范式，数据可以拆分保存到不同的数据表，彼此保持关联</p></li></ul><h3 id="mysql中的字段约束"><a class="markdownIt-Anchor" href="#mysql中的字段约束"></a> MySQL中的字段约束</h3><ul><li>主键约束 - PRIMARY KEY - 字段值唯一，且不能为NULL<ul><li>建议主键一定要使用数字类型，因为数字的检索速度会非常快</li><li>如果主键是数字类型，还可以设置自动增长</li></ul></li><li>非空约束 - NOT NULL - 字段值不能为NULL<ul><li>非空字段可以有默认值</li><li><code>name VARCHAR(20) NOT NULL DEFAULT &quot;default name&quot;</code></li></ul></li><li>唯一约束 - UNIQUE - 字段值唯一，且可以为NULL</li><li>外键约束 - FOREIGN KEY - 保持关联数据的逻辑性</li></ul><h2 id="外键约束的闭环问题"><a class="markdownIt-Anchor" href="#外键约束的闭环问题"></a> 外键约束的闭环问题</h2><ul><li>如果形成外键闭环，我们将无法删除任何一张表的记录</li></ul><h1 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h1><h2 id="数据排序的好处"><a class="markdownIt-Anchor" href="#数据排序的好处"></a> 数据排序的好处</h2><ul><li>一旦数据排序之后，查找的速度就会翻倍</li></ul><h2 id="如何创建索引"><a class="markdownIt-Anchor" href="#如何创建索引"></a> 如何创建索引</h2><ul><li>当数据排序后，MySQL后台会对索引对象创建二叉树，使用二分查找提升速度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table t_message (</span><br><span class="line">    id int unsigned primary key,</span><br><span class="line">    content varchar(200) not null,</span><br><span class="line">    type enum(&quot;notification&quot;, &quot;annocement&quot;, &quot;letter&quot;) not null,</span><br><span class="line">    create_time timestamp not null,</span><br><span class="line">    INDEX idx_type (type)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="如何添加与删除索引"><a class="markdownIt-Anchor" href="#如何添加与删除索引"></a> 如何添加与删除索引</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">drop index idx_type on t_message;</span><br><span class="line"></span><br><span class="line">create index idx_type on t_message(type);</span><br><span class="line"></span><br><span class="line">show index from t_message;</span><br><span class="line"></span><br><span class="line">alter table t_message add index idx_type(type);</span><br></pre></td></tr></table></figure><h2 id="索引的使用原则"><a class="markdownIt-Anchor" href="#索引的使用原则"></a> 索引的使用原则</h2><ul><li>数据量很大，而且经常被查询到的数据表可以设置索引</li><li>索引只添加在经常被用作检索条件的字段上面</li><li>不要在大字段上创建索引</li></ul><h1 id="数据操作语言"><a class="markdownIt-Anchor" href="#数据操作语言"></a> 数据操作语言</h1><h2 id="记录查询"><a class="markdownIt-Anchor" href="#记录查询"></a> 记录查询</h2><ul><li>最基本的查询语言是由select和from关键字组成的</li><li>select语句屏蔽了物理层的操作，用户不必关心数据的真实存储，交由数据库高效的查找数据</li></ul><h2 id="使用列别名"><a class="markdownIt-Anchor" href="#使用列别名"></a> 使用列别名</h2><ul><li>通常情况下，select子句中使用了表达式，那么这列的名字就默认为表达式，因此需要一种对列名重命名的机制</li></ul><h2 id="数据分页"><a class="markdownIt-Anchor" href="#数据分页"></a> 数据分页</h2><ul><li>如果记录很多，我们可以使用LIMIT关键字来限定结果数量</li><li><code>Select ... from ... limit startPosition, offset</code></li><li>如果LIMIT子句只有一个参数，他表示的是offset，起始值默认为0</li></ul><h2 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h2><ul><li>如果没有设置，查询语句不会对结果集进行排序，如果想让结果按照某种顺序排列，就必须使用ORDER BY子句</li><li>ASC代表升序，DESC代表降序</li><li>如果排序列是数字类型，数据库就按照数字大小排列，如果是日期类型，就按照日期排序，如果是字符串就按照字符集序号排序</li></ul><h2 id="去除重复记录"><a class="markdownIt-Anchor" href="#去除重复记录"></a> 去除重复记录</h2><ul><li>DISTINCT</li><li>DISTINCT关键字只能使用一次，并且放在最前面</li></ul><h2 id="条件查询"><a class="markdownIt-Anchor" href="#条件查询"></a> 条件查询</h2><ul><li>WHERE</li></ul><h2 id="聚合函数"><a class="markdownIt-Anchor" href="#聚合函数"></a> 聚合函数</h2><ul><li>求和，最大值，最小值，平均值，COUNT。。。</li></ul><h2 id="数据分组"><a class="markdownIt-Anchor" href="#数据分组"></a> 数据分组</h2><ul><li>GROUP BY</li><li>通过一定的规则讲一个数据集划分成若干个小的区域，然后针对每个小区域分别进行数据汇总处理</li><li>数据库支持多列分组条件，执行的时候逐级分组</li><li>WITH ROLLUP 对分组结果再次做汇总计算</li></ul><h3 id="group_concat函数"><a class="markdownIt-Anchor" href="#group_concat函数"></a> GROUP_CONCAT函数</h3><ul><li><p>把分组查询中的某个字段拼接成一个字符串</p></li><li><p>查询每个部门工资大于2000 的</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select deptno, GROUP_CONCAT(ename), COUNT(*)</span><br><span class="line">from t_emp</span><br><span class="line">where sal &gt;&#x3D; 2000</span><br><span class="line">group by deptno;</span><br></pre></td></tr></table></figure><h3 id="having子句"><a class="markdownIt-Anchor" href="#having子句"></a> HAVING子句</h3><ul><li>查询每个部门中，1982年以后入职的员工超过2个人的部门编号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select deptno</span><br><span class="line">from t_emp</span><br><span class="line">where hiredate &gt;&#x3D; &quot;1982-01-01&quot;</span><br><span class="line">group by deptno </span><br><span class="line">having COUNT(*) &gt;&#x3D; 2</span><br></pre></td></tr></table></figure><h2 id="表连接"><a class="markdownIt-Anchor" href="#表连接"></a> 表连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select e.empno, e.ename, d.dname</span><br><span class="line">from t_emp e join t_dept d</span><br><span class="line">on e.deptno &#x3D; d.deptno;</span><br></pre></td></tr></table></figure><h3 id="表连接的分类"><a class="markdownIt-Anchor" href="#表连接的分类"></a> 表连接的分类</h3><ul><li>内连接，外连接</li><li>内连接是结果集中只保留符合连接条件的记录</li><li>外连接是不管符不符合连接条件，记录都要保留在结果集中</li></ul><h3 id="内连接"><a class="markdownIt-Anchor" href="#内连接"></a> 内连接</h3><ul><li>用于查询多张关系表符合条件的记录</li><li>INNER JOIN</li><li>相同的数据表也可以做表连接</li></ul><h3 id="外连接"><a class="markdownIt-Anchor" href="#外连接"></a> 外连接</h3><ul><li><p>LEFT JOIN</p></li><li><p>RIGHT JOIN</p></li><li><p>左外连接就是保留左表所有的记录，与右表做链接，如果右表有符合条件的记录就与左表链接，如果没有，就用NULL与左表链接</p></li><li><p>右外连接也是如此</p></li><li><p>UNION关键字可以将多个查询语句的结果集进行合并</p></li><li><p>查询每个部门的人数，没有部门的员工用NULL代表部门的名称</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">    select d.dname, COUNT(e.deptno)</span><br><span class="line">    from t_dept d LEFT JOIN t_emp e</span><br><span class="line">    on d.deptno &#x3D; e.deptno</span><br><span class="line">    GROUP BY d.deptno</span><br><span class="line">) </span><br><span class="line">UNION</span><br><span class="line">(</span><br><span class="line">    select d.name, COUNT(*)</span><br><span class="line">    from t_dept d RIGHT JOIN t_emp e</span><br><span class="line">    ON d.deptno &#x3D; e.deptno</span><br><span class="line">    GROUP BY d.deptno</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>在外链接里，条件写在WHERE子句里，不符合条件的记录会被过滤掉，不会被保留下来</li></ul><h2 id="子查询"><a class="markdownIt-Anchor" href="#子查询"></a> 子查询</h2><ul><li>嵌套在查询语句中的查询</li><li>子查询可以写在三个地方： WHERE， FROM， SELECT</li><li>只有写在FROM中的子查询是最可取的，其他地方的效率不高</li></ul><h3 id="where子句中的多行子查询"><a class="markdownIt-Anchor" href="#where子句中的多行子查询"></a> WHERE子句中的多行子查询</h3><ul><li>可以使用IN， ALL， ANY， EXISTS关键字来处理多行表达式结果集的条件判断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select ename from t_emp</span><br><span class="line">where sal &gt; ALL (100, 200)</span><br></pre></td></tr></table></figure><h3 id="exists-关键字"><a class="markdownIt-Anchor" href="#exists-关键字"></a> EXISTS 关键字</h3><ul><li>把原来在子查询之外的条件判断写到了子查询的里面</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT SupplierName</span><br><span class="line">FROM Suppliers</span><br><span class="line">WHERE EXISTS </span><br><span class="line">(</span><br><span class="line">    SELECT ProductName </span><br><span class="line">    FROM Products </span><br><span class="line">    WHERE Products.SupplierID &#x3D; Suppliers.supplierID </span><br><span class="line">    AND Price &lt; 20</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="数据操作语言-2"><a class="markdownIt-Anchor" href="#数据操作语言-2"></a> 数据操作语言</h1><h2 id="insert语句"><a class="markdownIt-Anchor" href="#insert语句"></a> INSERT语句</h2><ul><li>向数据表中写入记录，可以使一条记录也可以是多条记录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into table_name (column_1, column_2, ...)</span><br><span class="line">values (value_1, value_2, ...);</span><br></pre></td></tr></table></figure><ul><li>写入多条记录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert into table_name (column_1, column_2, ...)</span><br><span class="line">values </span><br><span class="line">(value_1, value_2, ...),</span><br><span class="line">(value_1, value_2, ...),</span><br><span class="line">(value_1, value_2, ...);</span><br></pre></td></tr></table></figure><h2 id="ignore关键字"><a class="markdownIt-Anchor" href="#ignore关键字"></a> IGNORE关键字</h2><ul><li>会让INSERT只插入数据库不存在的记录,不会报错</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert ignore into table_name (...) values (...);</span><br></pre></td></tr></table></figure><h2 id="update语句"><a class="markdownIt-Anchor" href="#update语句"></a> UPDATE语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update table_name set column_name &#x3D; value_name, ....;</span><br></pre></td></tr></table></figure><h3 id="update语句的表连接"><a class="markdownIt-Anchor" href="#update语句的表连接"></a> UPDATE语句的表连接</h3><ul><li>可以修改多张表的记录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update table_1 join table_2 on condition</span><br><span class="line">set column_1 &#x3D; value_1, column_2 &#x3D; value_2,...;</span><br></pre></td></tr></table></figure><h2 id="delete-语句"><a class="markdownIt-Anchor" href="#delete-语句"></a> DELETE 语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from table_name</span><br><span class="line">where ...;</span><br></pre></td></tr></table></figure><h3 id="delete语句的表连接"><a class="markdownIt-Anchor" href="#delete语句的表连接"></a> DELETE语句的表连接</h3><ul><li>删除多张表的记录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete table_1, table_2</span><br><span class="line">from table_1 join table_2 on condition</span><br><span class="line">where...;</span><br></pre></td></tr></table></figure><h1 id="事务机制"><a class="markdownIt-Anchor" href="#事务机制"></a> 事务机制</h1><h2 id="避免写入直接操作数据文件"><a class="markdownIt-Anchor" href="#避免写入直接操作数据文件"></a> 避免写入直接操作数据文件</h2><ul><li>利用日志来实现间接写入</li><li>redo，undo日志</li></ul><h2 id="transaction"><a class="markdownIt-Anchor" href="#transaction"></a> Transaction</h2><ul><li>全部成功或者全部失败</li><li>默认情况下，MySQL执行每条SQL语句都会自动开启和提交事务</li><li>为了让多条SQL语句纳入到一个事务之下，可以手动管理事务</li><li><code>start transaction;</code></li></ul><h2 id="acid"><a class="markdownIt-Anchor" href="#acid"></a> ACID</h2><h3 id="原子性"><a class="markdownIt-Anchor" href="#原子性"></a> 原子性</h3><ul><li>全部成功或者全部失败， 没有中间状态</li></ul><h3 id="一致性"><a class="markdownIt-Anchor" href="#一致性"></a> 一致性</h3><ul><li>不管在任何给定时间，并发事务有多少，事务必须保证运行结果的一致性</li><li>事务的临时状态不会被读取</li></ul><h3 id="隔离性"><a class="markdownIt-Anchor" href="#隔离性"></a> 隔离性</h3><ul><li>事务不受其他并发事务的影响，如同再给定时间内，改事务是数据库唯一运行的事务</li><li>默认情况下，只能看到日志中该事物的相关数据</li></ul><h3 id="持久性"><a class="markdownIt-Anchor" href="#持久性"></a> 持久性</h3><ul><li>事务一旦提交，结果便是永久性的，即便发生宕机，仍然可以依靠事务日志完成数据的持久化</li></ul><h2 id="隔离级别"><a class="markdownIt-Anchor" href="#隔离级别"></a> 隔离级别</h2><h3 id="read-uncommitted"><a class="markdownIt-Anchor" href="#read-uncommitted"></a> READ UNCOMMITTED</h3><ul><li>代表可以读取日志中其他事物的未提交的数据，即使其他事物还没有commit</li><li><code>set session transaction isolation level read uncommitted;</code></li></ul><h3 id="read-committed"><a class="markdownIt-Anchor" href="#read-committed"></a> READ COMMITTED</h3><ul><li>代表只能读取其他事物提交的数据</li><li><code>set session transaction isolation level read committed;</code></li></ul><h3 id="repeatable-read-默认级别"><a class="markdownIt-Anchor" href="#repeatable-read-默认级别"></a> REPEATABLE READ （默认级别）</h3><ul><li>事务在执行中反复读取数据，得到的结果是一致的，不会受到其他事物的影响</li><li><code>set session transaction isolation level repeatable read;</code></li></ul><h3 id="serializable"><a class="markdownIt-Anchor" href="#serializable"></a> SERIALIZABLE</h3><ul><li>让事务逐一执行，不存在并发性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是数据库系统&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是数据库系统&quot;&gt;&lt;/a&gt; 什么是数据库系统&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;DBMS是指一个能为用户提供信息服务的系统，它实现了有组织的，动态的储存大量相关数据的功能，提供</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://hellcy.github.io/tags/MySQL/"/>
    
    <category term="Database" scheme="http://hellcy.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Frontend Basics</title>
    <link href="http://hellcy.github.io/2022/02/15/Frontend-Basics/"/>
    <id>http://hellcy.github.io/2022/02/15/Frontend-Basics/</id>
    <published>2022-02-15T06:42:21.000Z</published>
    <updated>2022-02-16T04:34:04.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jquery"><a class="markdownIt-Anchor" href="#jquery"></a> jQuery</h1><ul><li>为了简化JS开发的第三方库 （jQuery，Vue，AngularJS，React）</li><li>jQuery的核心是选择器，用于获取页面元素</li></ul><h2 id="选择器"><a class="markdownIt-Anchor" href="#选择器"></a> 选择器</h2><h3 id="基本选择器"><a class="markdownIt-Anchor" href="#基本选择器"></a> 基本选择器</h3><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td><code>$(&quot;#id&quot;)</code></td><td>ID选择器，指定ID元素的对象</td></tr><tr><td><code>$(&quot;标签&quot;)</code></td><td>元素选择器，选择指定标签名的选择器</td></tr><tr><td><code>$(&quot;.class&quot;)</code></td><td>类选择器，选中拥有指定css类的元素</td></tr><tr><td><code>$(&quot;S1, S2, S3&quot;)</code></td><td>组合选择器，对元素进行组合</td></tr></tbody></table><h3 id="层叠选择器"><a class="markdownIt-Anchor" href="#层叠选择器"></a> 层叠选择器</h3><ul><li>根据元素的位置关系来获取元素的选择器表达式</li></ul><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td><code>$(&quot;ancestor descendant&quot;)</code></td><td>后代选择器，选择父节点的所有后代子节点（包括后代的后代的后代。。。）</td></tr><tr><td><code>$(&quot;ancestor&gt;descendant&quot;)</code></td><td>子选择器，只选择父节点的直接子节点</td></tr><tr><td><code>$(&quot;prev~siblings&quot;)</code></td><td>兄弟选择器，只会选择同级别的，在当前元素之后的兄弟元素</td></tr></tbody></table><h3 id="属性选择器"><a class="markdownIt-Anchor" href="#属性选择器"></a> 属性选择器</h3><ul><li>属性选择器是根据元素的属性值来选择元素的选择器表达式</li></ul><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td><code>$(&quot;selector[attribute=value]&quot;)</code></td><td>选中属性值等于具体值得组件</td></tr><tr><td><code>$(&quot;selector[attribute^=value]&quot;)</code></td><td>选中属性值以某值开头得组件</td></tr><tr><td><code>$(&quot;selector[attribute$=value]&quot;)</code></td><td>选中属性值以某值结尾得组件</td></tr><tr><td><code>$(&quot;selector[attribute*=value]&quot;)</code></td><td>选中属性值包含某值得组件</td></tr></tbody></table><h3 id="位置选择器"><a class="markdownIt-Anchor" href="#位置选择器"></a> 位置选择器</h3><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td><code>$(&quot;selector:first&quot;)</code></td><td>获取第一个元素</td></tr><tr><td><code>$(&quot;selector:last&quot;)</code></td><td>获取最后一个元素</td></tr><tr><td><code>$(&quot;selector:even&quot;)</code></td><td>获取偶数位置的元素（从0开始）</td></tr><tr><td><code>$(&quot;selector:odd&quot;)</code></td><td>获取奇数位置的元素（从0开始）</td></tr><tr><td><code>$(&quot;selector:eq(n)&quot;)</code></td><td>获取指定位置的元素（从0开始）</td></tr></tbody></table><h3 id="表单选择器"><a class="markdownIt-Anchor" href="#表单选择器"></a> 表单选择器</h3><ul><li>获取表单元素的简化形式</li></ul><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td><code>$(&quot;selector:input&quot;)</code></td><td>所有输入元素</td></tr><tr><td><code>$(&quot;selector:text&quot;)</code></td><td>获取文本框</td></tr><tr><td><code>$(&quot;selector:password&quot;)</code></td><td>获取密码框</td></tr><tr><td><code>$(&quot;selector:submit&quot;)</code></td><td>获取调教按钮</td></tr><tr><td><code>$(&quot;selector:reset&quot;)</code></td><td>获取重置按钮</td></tr></tbody></table><h2 id="操作元素"><a class="markdownIt-Anchor" href="#操作元素"></a> 操作元素</h2><h3 id="操作元素属性"><a class="markdownIt-Anchor" href="#操作元素属性"></a> 操作元素属性</h3><ul><li>.attr()</li><li>.removeAttr()</li></ul><h3 id="操作元素css样式"><a class="markdownIt-Anchor" href="#操作元素css样式"></a> 操作元素CSS样式</h3><ul><li>css() - 获取或者设置匹配元素的样式属性</li><li>addclass() - 为每个匹配的元素添加指定的类名</li><li>removeClass() - 从所有匹配的元素中删除全部或者指定的类</li></ul><h3 id="设置元素内容"><a class="markdownIt-Anchor" href="#设置元素内容"></a> 设置元素内容</h3><ul><li>val() - 获取或设置输入项的值</li><li>text() - 获取或设置元素的纯文本</li><li>html() - 获取或设置元素内部的HTML</li></ul><h3 id="jquery事件处理方法"><a class="markdownIt-Anchor" href="#jquery事件处理方法"></a> jQuery事件处理方法</h3><ul><li><code>on(&quot;click&quot;, function)</code> - 为选中的页面元素绑定单机事件</li><li>click(function) - 是绑定事件的简写形式</li><li>处理方法中提供了event参数包含了事件的相关信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p.myClass&quot;).on(&quot;click&quot;, function() &#123;</span><br><span class="line">    &#x2F;&#x2F; $(this) 是指当前事件产生的对象，也就是p.myClass对象本身</span><br><span class="line">    $(this).css(&quot;backgroung-color&quot;, &quot;red&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="ajax"><a class="markdownIt-Anchor" href="#ajax"></a> Ajax</h2><ol><li>创建XMLHttpRequest对象</li><li>向服务器发送请求</li><li>服务器返回Response到JavaScript</li></ol><h2 id="jquery对ajax的支持"><a class="markdownIt-Anchor" href="#jquery对ajax的支持"></a> jQuery对Ajax的支持</h2><ul><li>jQuery对Ajax进行了封装，提供了<code>$.ajax()</code>方法<br />| 常用设置项 | 说明 |<br />| url | 发送请求地址 |<br />| type | 请求类型 get、post |<br />| data | 向服务器传递的参数 |<br />| dataType | 服务器响应的数据类型（text，json，xml，html，jsonp，script）|<br />| success | 接受响应时的处理函数 |<br />| error | 请求失败时的处理函数 |</li></ul><h1 id="过滤器"><a class="markdownIt-Anchor" href="#过滤器"></a> 过滤器</h1><ul><li>J2EE Servlet模块下的组件</li><li>Filter的作用是对URL进行统一的拦截处理</li><li>Filter通常用于应用程序层面进行全局处理</li></ul><h2 id="过滤器开发三要素"><a class="markdownIt-Anchor" href="#过滤器开发三要素"></a> 过滤器开发三要素</h2><ul><li>任何过滤器都要实现<code>javax.servlet.Filter</code>接口</li><li>在filter接口的<code>doFilter()</code>方法中编写过滤器的功能代码</li><li>在<code>web.xml</code>中对过滤器进行配置，说明拦截URL的范围,那些请求会被拦截，那些请求不会被拦截</li></ul><h2 id="过滤器的生命周期"><a class="markdownIt-Anchor" href="#过滤器的生命周期"></a> 过滤器的生命周期</h2><ul><li>初始化，Tomcat启动时 - Filter.init()</li><li>提供服务 - Filter.doFilter()</li><li>销毁 - 应用关闭或重启时 - Filter.destroy()</li></ul><h2 id="过滤器的特性"><a class="markdownIt-Anchor" href="#过滤器的特性"></a> 过滤器的特性</h2><ul><li>过滤器对象在Web应用启动时被创建且全局唯一</li><li>唯一的过滤器对象在并发环境中采用“单例多线程”提供服务<ul><li>过滤器会为每一个请求创建一个单独的线程</li></ul></li></ul><h2 id="过滤器的配置形式"><a class="markdownIt-Anchor" href="#过滤器的配置形式"></a> 过滤器的配置形式</h2><ul><li>所有的信息存放在web.xml中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;MyFirstFileter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;com.yuan.filter.MyFirstFileter&lt;&#x2F;filter-class&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;MyFirstFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure><h2 id="过滤器的注解形式"><a class="markdownIt-Anchor" href="#过滤器的注解形式"></a> 过滤器的注解形式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter(filterName &#x3D; &quot;MyAnnoationFilter&quot;, urlPatterns&#x3D;&quot;&#x2F;*&quot;)</span><br><span class="line">public class MyAnnotationFilter implements Filter &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置与注解如何选择"><a class="markdownIt-Anchor" href="#配置与注解如何选择"></a> 配置与注解如何选择</h2><ul><li>配置形式维护性更好，适合应用全局过滤</li><li>注解形式开发体验更好，适用于小型项目敏捷开发</li><li>注解形式每次过滤器的改变都需要重新编译、</li></ul><h2 id="过滤器参数化"><a class="markdownIt-Anchor" href="#过滤器参数化"></a> 过滤器参数化</h2><ul><li>过滤器为了增强灵活性，允许配置信息放在web.xml</li><li>在web.xml中配置<code>&lt;init-param&gt;</code>设置过滤器参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;init-param&gt;</span><br><span class="line">    &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;init-param&gt;</span><br></pre></td></tr></table></figure><ul><li>在Filter类中的init方法取得配置信息中的参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private String encoding &#x3D; filterConfig.getInitParameter(&quot;encoding&quot;);</span><br></pre></td></tr></table></figure><h2 id="过滤链"><a class="markdownIt-Anchor" href="#过滤链"></a> 过滤链</h2><ul><li>每一个过滤器应具有单独的功能</li><li>过滤器执行顺序以<code>&lt;filter-mapping&gt;</code>为准</li><li>调用chain.doFiler()将请求向后传递·</li></ul><h1 id="监听器-listener"><a class="markdownIt-Anchor" href="#监听器-listener"></a> 监听器 - Listener</h1><ul><li>对Web应用对象的行为进行监控</li><li>Listener是J2EE Servlet模块下的组件</li><li>Listener的作用是对web应用对象的行为进行监控</li><li>通过监听自动触发指定的功能代码</li></ul><h2 id="监听对象"><a class="markdownIt-Anchor" href="#监听对象"></a> 监听对象</h2><ul><li>ServletContext - 对全局context及其属性监听</li><li>HttpSession - 对用户会话及其属性监听</li><li>ServletRequest - 对请求及其属性监听</li></ul><h2 id="监听器和过滤器的区别"><a class="markdownIt-Anchor" href="#监听器和过滤器的区别"></a> 监听器和过滤器的区别</h2><ul><li>过滤器的职责是对URL进行过滤拦截，是主动的进行</li><li>监听器的职责是对web对象进行监听，是被动触发</li></ul><h2 id="开发监听器三要素"><a class="markdownIt-Anchor" href="#开发监听器三要素"></a> 开发监听器三要素</h2><ol><li>实现Listener接口，不同接口对应不同的监听对象</li><li>实现每个接口中独有的方法，实现触发监听后续操作</li><li>在web.xml中配置<code>&lt;listener&gt;</code>使监听器生效</li></ol><h2 id="六种常用监听接口"><a class="markdownIt-Anchor" href="#六种常用监听接口"></a> 六种常用监听接口</h2><ol><li>ServletContextListener</li><li>HttpSessionListener</li><li>ServletRequestListener</li></ol><h3 id="属性监听接口"><a class="markdownIt-Anchor" href="#属性监听接口"></a> 属性监听接口</h3><ol start="4"><li>ServletContextAttributeListener - 监听全局属性操作</li><li>HttpSessionAttributeListener - 监听用户会话属性操作</li><li>ServletRequestAttributeListener - 监听请求属性操作</li></ol><h1 id="模板引擎"><a class="markdownIt-Anchor" href="#模板引擎"></a> 模板引擎</h1><h2 id="什么是模板引擎"><a class="markdownIt-Anchor" href="#什么是模板引擎"></a> 什么是模板引擎</h2><ul><li>数据 + 模板 = 结果</li><li>将数据与展现有效的解耦</li></ul><h2 id="freemarker"><a class="markdownIt-Anchor" href="#freemarker"></a> Freemarker</h2><ul><li>脚本为Freemarker template language</li><li>提供了大量内建函数来简化开发</li></ul><h2 id="ftl取值"><a class="markdownIt-Anchor" href="#ftl取值"></a> FTL取值</h2><ul><li>${attribute} - 取值，可对属性进行计算</li><li>${attribute!default} - 使用默认值</li><li>${attribute?string} 格式化输出</li></ul><h2 id="分支判断"><a class="markdownIt-Anchor" href="#分支判断"></a> 分支判断</h2><ul><li>if else</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;#if computer.state &#x3D;&#x3D; 1&gt;</span><br><span class="line">    State: using</span><br><span class="line">&lt;#elseif computer.state &#x3D;&#x3D; 2&gt;</span><br><span class="line">    State: idle</span><br><span class="line">&lt;#elseif computer.state &#x3D;&#x3D; 3&gt;</span><br><span class="line">    State: finished</span><br><span class="line">&lt;&#x2F;#if&gt;</span><br></pre></td></tr></table></figure><ul><li>switch</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;#switch computer.state&gt;</span><br><span class="line">    &lt;#case 1&gt;</span><br><span class="line">        State: using</span><br><span class="line">        &lt;#break&gt;</span><br><span class="line">    &lt;#case 2&gt;</span><br><span class="line">        State: idle</span><br><span class="line">        &lt;#break&gt;</span><br><span class="line">    &lt;#case 3&gt;</span><br><span class="line">        State: finished</span><br><span class="line">        &lt;#break&gt;</span><br><span class="line">    &lt;#default &gt;</span><br><span class="line">        State: not exist</span><br><span class="line">&lt;&#x2F;#switch&gt;</span><br></pre></td></tr></table></figure><ul><li>check if value is null</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#if computer.user??&gt;</span><br><span class="line">    User: $&#123;computer.user&#125;</span><br><span class="line">&lt;&#x2F;#if&gt;</span><br></pre></td></tr></table></figure><h2 id="list迭代列表"><a class="markdownIt-Anchor" href="#list迭代列表"></a> list迭代列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#list students as stu&gt;</span><br><span class="line">    &lt;li&gt;$&#123;stu_index&#125;-$&#123;stu.name&#125;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;#list&gt;</span><br></pre></td></tr></table></figure><h2 id="list迭代map"><a class="markdownIt-Anchor" href="#list迭代map"></a> list迭代Map</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#list map?keys as key&gt;</span><br><span class="line">    $&#123;key&#125;:$&#123;map[key]&#125;</span><br><span class="line">&lt;&#x2F;#list&gt;</span><br></pre></td></tr></table></figure><h2 id="内建函数"><a class="markdownIt-Anchor" href="#内建函数"></a> 内建函数</h2><ul><li>lower_case/upper_case</li><li>cap_first</li><li>index_of</li><li>length</li><li>round/floor/ceiling</li><li>size</li><li>first/last</li><li>sort_by</li></ul><h1 id="mvc模式"><a class="markdownIt-Anchor" href="#mvc模式"></a> MVC模式</h1><h2 id="model"><a class="markdownIt-Anchor" href="#model"></a> Model</h2><ul><li>负责生产业务需要的数据</li></ul><h2 id="controller"><a class="markdownIt-Anchor" href="#controller"></a> Controller</h2><ul><li>接受来自web的请求</li><li>调用service进行处理</li><li>将数据放入request</li><li>跳转界面</li></ul><h2 id="view"><a class="markdownIt-Anchor" href="#view"></a> View</h2><ul><li>用于展示最终结果</li><li>通常使用模板引擎展示</li></ul><h2 id="mvc优点"><a class="markdownIt-Anchor" href="#mvc优点"></a> MVC优点</h2><ul><li>软件团队分工合作，成员各司其职</li><li>分层开发，显示与数据解耦，便于维护</li><li>组件可灵活替代，互不影响</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jquery&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jquery&quot;&gt;&lt;/a&gt; jQuery&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;为了简化JS开发的第三方库 （jQuery，Vue，AngularJS，React）&lt;/li&gt;
&lt;li&gt;jQ</summary>
      
    
    
    
    
    <category term="Frontend" scheme="http://hellcy.github.io/tags/Frontend/"/>
    
  </entry>
  
  <entry>
    <title>Servlet and JSP</title>
    <link href="http://hellcy.github.io/2022/02/15/Servlet-and-JSP/"/>
    <id>http://hellcy.github.io/2022/02/15/Servlet-and-JSP/</id>
    <published>2022-02-15T03:46:18.000Z</published>
    <updated>2022-02-15T17:10:55.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件结构"><a class="markdownIt-Anchor" href="#软件结构"></a> 软件结构</h1><h2 id="单机时代-桌面应用"><a class="markdownIt-Anchor" href="#单机时代-桌面应用"></a> 单机时代 - 桌面应用</h2><ul><li>单机应用，软件所有数据都保存在电脑本地硬盘中</li><li>易于使用，结构简单</li><li>缺点： 数据难以共享，安全性差，更新不及时</li></ul><h2 id="client-server模式"><a class="markdownIt-Anchor" href="#client-server模式"></a> Client-Server模式</h2><ul><li>数据保存在服务器上</li><li>客户端通过与服务器进行通讯来获取数据</li><li>优点：数据方便共享，安全性高</li><li>缺点：必须安装客户端，升级与维护困难</li></ul><h2 id="browser-server模式"><a class="markdownIt-Anchor" href="#browser-server模式"></a> Browser-Server模式</h2><ul><li>编写网页，通过服务器动态生成网页</li><li>优点：开发简单，无需安装客户端，数据以与共享</li><li>缺点：执行速度与用户体验相对较弱</li></ul><h2 id="请求与响应"><a class="markdownIt-Anchor" href="#请求与响应"></a> 请求与响应</h2><ul><li>从浏览器发出送给服务器的数据包成为：请求 Request</li><li>从服务器返回给浏览器的结果成为： 响应 Response</li></ul><h1 id="j2ee是什么"><a class="markdownIt-Anchor" href="#j2ee是什么"></a> J2EE是什么</h1><ul><li>J2EE是指Java 2 企业版</li><li>开发Web应用程序就是J2EE最核心的功能</li><li>J2EE由13个功能模块组成</li></ul><h2 id="13个功能模块"><a class="markdownIt-Anchor" href="#13个功能模块"></a> 13个功能模块</h2><h3 id="重要"><a class="markdownIt-Anchor" href="#重要"></a> 重要</h3><ol><li>Servlet - web服务器小程序</li><li>JSP - 服务器页面</li><li>JDBC - 数据库交互模块</li><li>XML - XML交互模块</li></ol><h3 id="次要"><a class="markdownIt-Anchor" href="#次要"></a> 次要</h3><ol start="5"><li>EJB - 企业级Java Bean</li><li>RMI - 远程调用</li><li>JNDI - 目录服务</li><li>JMS - 消息服务</li><li>JTA - 事务管理</li><li>JavaMail - 发送接收Email</li><li>JAF - 安全框架</li><li>CORBA - CORBA集成</li><li>JTS - CORBA事务监控</li></ol><h1 id="apache-tomcat"><a class="markdownIt-Anchor" href="#apache-tomcat"></a> Apache Tomcat</h1><ul><li>Tomcat是Apache软件基金会旗下一款免费的开源Web应用服务器程序</li></ul><h2 id="j2ee与tomcat的关系"><a class="markdownIt-Anchor" href="#j2ee与tomcat的关系"></a> J2EE与Tomcat的关系</h2><ul><li>J2EE是一组技术规范与指南，具体实现由软件厂商决定</li><li>Tomcat是J2EE Web（Servlet与JSP）标准的实现者</li><li>J2SE是J2EE运行的基石，运行Tomcat离不开J2SE</li></ul><h1 id="servlet"><a class="markdownIt-Anchor" href="#servlet"></a> Servlet</h1><ul><li>Servlet(Server Applet)服务器小程序，主要功能用于生成动态Web内容</li><li>Servlet是J2EE最重要的组成部分，也是我们学习的重点</li></ul><p><img src="/images/Servlet-and-JSP/1.png" alt="" /></p><h2 id="install-tomcat-on-macos"><a class="markdownIt-Anchor" href="#install-tomcat-on-macos"></a> Install Tomcat on macOS</h2><ul><li><a href="https://jeongwhanchoi.medium.com/how-to-install-apache-tomcat-on-mac-os-x-605b1cb55252">Install Tomcat on macOS</a></li><li>after successfully installation, you can use <code>./start.sh</code> in Terminal to start Tomcat</li><li>you can go to <code>localhost:8080</code> to check if Tomcat is running</li></ul><h2 id="servlet开发步骤"><a class="markdownIt-Anchor" href="#servlet开发步骤"></a> Servlet开发步骤</h2><ul><li>创建Servlet类，继承HttpServlet （类似于之后SpringMVC的Controller）</li><li>重写service方法，编写程序代码</li><li>配置web.xml，绑定URL</li></ul><h2 id="请求参数"><a class="markdownIt-Anchor" href="#请求参数"></a> 请求参数</h2><ul><li>请求参数是指浏览器通过请求向Tomcat提交的数据</li><li>请求参数通常是用户输入的数据，待Servlet进行处理</li><li>用&amp;符号连接</li></ul><h2 id="get与post请求方法"><a class="markdownIt-Anchor" href="#get与post请求方法"></a> Get与Post请求方法</h2><ul><li>Get方式是将数据通过在URL附加数据显性向服务器发送数据<ul><li>常用于不包含敏感信息的查询功能</li></ul></li><li>Post方式会将数据存放在Form中隐性向服务器发送数据<ul><li>常用于安全性较高的功能或者服务器的写操作</li><li>用户登录</li><li>用户注册</li><li>更新公司账目</li></ul></li></ul><h2 id="servlet生命周期"><a class="markdownIt-Anchor" href="#servlet生命周期"></a> Servlet生命周期</h2><ol><li>装载 - web.xml</li><li>创建 - 构造函数</li><li>初始化 - init()</li><li>提供服务 - service()</li><li>销毁 - destroy()</li></ol><h2 id="使用注解简化配置"><a class="markdownIt-Anchor" href="#使用注解简化配置"></a> 使用注解简化配置</h2><ul><li><code>@WebServlet</code></li></ul><h2 id="启动时加载servlet"><a class="markdownIt-Anchor" href="#启动时加载servlet"></a> 启动时加载Servlet</h2><ul><li>web.xml 使用<code>&lt;load-on-startup&gt;</code>设置启动加载</li><li>在工作中常用于系统的预处理</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;软件结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#软件结构&quot;&gt;&lt;/a&gt; 软件结构&lt;/h1&gt;
&lt;h2 id=&quot;单机时代-桌面应用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#单机时代-桌面应用&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="Java" scheme="http://hellcy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>XML Basics</title>
    <link href="http://hellcy.github.io/2022/02/14/XML-Basics/"/>
    <id>http://hellcy.github.io/2022/02/14/XML-Basics/</id>
    <published>2022-02-14T06:47:24.000Z</published>
    <updated>2022-02-15T03:31:57.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xml是什么"><a class="markdownIt-Anchor" href="#xml是什么"></a> XML是什么</h1><ul><li>XML的全称是Exensible Markup Language，可扩展标记语言</li><li>编写XML就是编写标签，与HTML非常相似</li><li>良好的人机可读性</li></ul><h2 id="xml与html的比较"><a class="markdownIt-Anchor" href="#xml与html的比较"></a> XML与HTML的比较</h2><ul><li>XML与HTML非常相似，都是编写标签</li><li>XML没有预定义的标签，HTML存在大量预定义的标签</li><li>XML重在保存与传输数据，HTML用于显示信息</li></ul><h1 id="xml的用途"><a class="markdownIt-Anchor" href="#xml的用途"></a> XML的用途</h1><ul><li>作为应用配置文件</li><li>用于保存程序产生的数据</li><li>网络间的数据传输，利用soap协议</li></ul><h1 id="xml文档结构"><a class="markdownIt-Anchor" href="#xml文档结构"></a> XML文档结构</h1><ul><li>第一行必须是XML声明</li><li>有且只有一个根节点</li><li>XML标签的书写规则与HTML相同</li></ul><h2 id="xml声明"><a class="markdownIt-Anchor" href="#xml声明"></a> XML声明</h2><ul><li>XML声明说明XML文档的基本信息，包括版本号与字符集，写在XML第一行</li><li><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></li></ul><h1 id="xml标签书写规则"><a class="markdownIt-Anchor" href="#xml标签书写规则"></a> XML标签书写规则</h1><h2 id="合法的标签名"><a class="markdownIt-Anchor" href="#合法的标签名"></a> 合法的标签名</h2><ul><li>标签名要有意义</li><li>建议使用英文小写字母，单词之间使用<code>-</code>分割</li><li>建议多级标签之间不要存在重名的情况</li></ul><h2 id="适当的注释与缩进"><a class="markdownIt-Anchor" href="#适当的注释与缩进"></a> 适当的注释与缩进</h2><ul><li>更容易阅读</li></ul><h2 id="合理使用属性"><a class="markdownIt-Anchor" href="#合理使用属性"></a> 合理使用属性</h2><ul><li>具有唯一性的值可以作为属性</li></ul><h2 id="处理特殊字符"><a class="markdownIt-Anchor" href="#处理特殊字符"></a> 处理特殊字符</h2><ul><li><code>&lt;</code>和<code>&gt;</code></li><li><code>&amp;lt;</code>和<code>&amp;gt;</code></li></ul><h2 id="cdata标签"><a class="markdownIt-Anchor" href="#cdata标签"></a> CDATA标签</h2><ul><li>CDATA指的是不应由XML解析器进行解析的文本数据</li><li><code>&lt;![CDATA[&quot;content&quot;]]&gt;</code></li></ul><h2 id="有序的子元素"><a class="markdownIt-Anchor" href="#有序的子元素"></a> 有序的子元素</h2><ul><li>在XML多层嵌套的子元素中，标签前后顺序应保持一致</li></ul><h1 id="xml语义约束"><a class="markdownIt-Anchor" href="#xml语义约束"></a> XML语义约束</h1><ul><li>XML文档结构正确，但可能不是有效的</li><li>XML语义约束有两种定义方式，DTD和XML Schema</li></ul><h2 id="document-type-definition"><a class="markdownIt-Anchor" href="#document-type-definition"></a> Document Type Definition</h2><ul><li>文件扩展名为 .dtd</li><li>在XML中使用<code>&lt;!DOCTYPE&gt;</code>标签来引用DTD文件</li></ul><h2 id="xml-schema"><a class="markdownIt-Anchor" href="#xml-schema"></a> XML Schema</h2><ul><li>文件扩展名为 .xsd</li><li>比DTD更为复杂，提供了更多功能</li><li>提供了数据类型，格式限定，数据范围等特性</li><li>是W3C标准</li></ul><h1 id="dom文档对象模型"><a class="markdownIt-Anchor" href="#dom文档对象模型"></a> DOM文档对象模型</h1><ul><li>Document Object Model 定义了访问和操作XML文档的标准方法，DOM把XML文档作为树结构来查看，能够通过DOM树来读写所有元素</li></ul><h2 id="dom4j"><a class="markdownIt-Anchor" href="#dom4j"></a> Dom4j</h2><ul><li>一个易用的，开源的库，用于解析XML，它应用于Java平台，具有性能优异，功能强大和及其易用的特点</li><li>Dom4j将XML视为document对象</li><li>XML标签被Dom4j定义为element对象</li></ul><h1 id="xpath路径表达式"><a class="markdownIt-Anchor" href="#xpath路径表达式"></a> XPath路径表达式</h1><ul><li>XML文档中查找数据的语言</li><li>掌握XPath可以极大地提高在提取数据时的开发效率</li><li>学习XPath本质就是掌握各种形式表达式的使用技巧</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xml是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#xml是什么&quot;&gt;&lt;/a&gt; XML是什么&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;XML的全称是Exensible Markup Language，可扩展标记语言&lt;/li&gt;
&lt;li&gt;编写XM</summary>
      
    
    
    
    
    <category term="XML" scheme="http://hellcy.github.io/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency</title>
    <link href="http://hellcy.github.io/2022/02/12/Java-Concurrency/"/>
    <id>http://hellcy.github.io/2022/02/12/Java-Concurrency/</id>
    <published>2022-02-12T10:23:56.000Z</published>
    <updated>2022-02-12T12:11:41.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是进程"><a class="markdownIt-Anchor" href="#什么是进程"></a> 什么是进程</h1><ul><li>进程是指可执行程序并存放在计算机存储器的一个指令序列，他是一个动态执行的过程</li></ul><h1 id="什么是线程"><a class="markdownIt-Anchor" href="#什么是线程"></a> 什么是线程</h1><ul><li>线程是比进程还要小的运行单位，一个进程包含多个线程</li><li>线程可以看做一个子程序</li></ul><h1 id="线程的创建"><a class="markdownIt-Anchor" href="#线程的创建"></a> 线程的创建</h1><ul><li>创建一个Thread类，或者一个Thread子类的对象</li><li>创建一个实现了Runnable接口的类的对象</li><li>创建一个实现了Callable接口的类的对象</li></ul><h2 id="继承thread类"><a class="markdownIt-Anchor" href="#继承thread类"></a> 继承Thread类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class CustomThread extends Thread &#123;</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    System.out.println(getName() + &quot; thread is running&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="runnable-接口"><a class="markdownIt-Anchor" href="#runnable-接口"></a> Runnable 接口</h2><ul><li>只有一个方法run()</li><li>Runnable是Java中用已实现线程的接口</li><li>任何实现线程功能的类都必须实现该接口</li><li>为什么要实现runnable接口？<ul><li>Java不支持多重继承，如果一个类已经继承了一个父类，那么他只能通过实现runnable接口变成线程</li><li>可以不重写Thread类的其他方法，只需要重写Run()方法</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class PrintRunnable implements Runnable&#123;</span><br><span class="line">  int i &#x3D; 1;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    while (i &lt;&#x3D; 10) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + &quot; is running &quot; + (i++));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class PrintRunnableTest &#123;</span><br><span class="line">  @Test</span><br><span class="line">  public void testRunnableThread() &#123;</span><br><span class="line">    PrintRunnable runnable1 &#x3D; new PrintRunnable();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; use runnable object to create thread</span><br><span class="line">    &#x2F;&#x2F; 2 threads are sharing the same variable</span><br><span class="line">    Thread t1 &#x3D; new Thread(runnable1);</span><br><span class="line">    t1.start();</span><br><span class="line"></span><br><span class="line">    Thread t2 &#x3D; new Thread(runnable1);</span><br><span class="line">    t2.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现callable接口"><a class="markdownIt-Anchor" href="#实现callable接口"></a> 实现callable接口</h2><ul><li>重写call()方法，作为线程的主体，具有返回值，并且可以对异常进行声明和抛出， 使用start()方法来启动线程</li></ul><ol><li>创建callable接口的实现类，并实现call()方法</li><li>创建callable实现类的实例，使用FutureTask类来包装callable对象，该FutureTask对象封装了callable对象的call()方法的返回值</li><li>使用FutureTask对象作为Thread对象的target，创建并启动线程</li><li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</li></ol><ul><li>实现callable接口，创建线程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class CustomThread implements Callable&lt;String&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        String str &#x3D; &quot;thread message&quot;;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>test thread</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testCustomThread() &#123;</span><br><span class="line">    Callable&lt;String&gt; callObj &#x3D; new CustomThread();</span><br><span class="line">    FutureTask&lt;String&gt; ft &#x3D; new FutureTask&lt;&gt;(callObj);</span><br><span class="line">    Thread thread &#x3D; new Thread(ft);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; start thread</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; the return value can only be got after thread has been started</span><br><span class="line">    try &#123;</span><br><span class="line">      System.out.println(ft.get());</span><br><span class="line">    &#125; catch (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程的状态"><a class="markdownIt-Anchor" href="#线程的状态"></a> 线程的状态</h1><ol><li>new</li><li>runnable</li><li>running</li><li>blocked</li><li>dead</li></ol><p><img src="/../images/Java-Concurrency/1.png" alt="" /></p><h2 id="sleep方法的使用"><a class="markdownIt-Anchor" href="#sleep方法的使用"></a> sleep方法的使用</h2><ul><li><code>public static void sleep(long millis)</code></li><li>作用：在指定的毫秒数内让正在执行的线程休眠（暂停执行）</li><li>参数为休眠的时间，单位是毫秒</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while (i &lt;&#x3D; 30) &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot; is running &quot; + (i++));</span><br><span class="line">    try &#123;</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="join方法应用"><a class="markdownIt-Anchor" href="#join方法应用"></a> join方法应用</h2><ul><li><code>public final void join()</code></li><li>等待调用该方法的线程结束后才能执行 （调用者抢占CPU使用权）</li><li><code>public final void join(long millis)</code></li><li>等待该线程终止的最长时间为millis毫秒</li></ul><h2 id="线程优先级"><a class="markdownIt-Anchor" href="#线程优先级"></a> 线程优先级</h2><ul><li>Java为线程类提供了10个优先级</li><li>优先级可以用整数1-10表示，超过范围会抛出异常</li><li>主线程默认优先级为5</li><li><code>getPriority()</code></li><li><code>setPriority()</code></li></ul><h3 id="优先级常量"><a class="markdownIt-Anchor" href="#优先级常量"></a> 优先级常量</h3><ul><li>MAX_PRIORITY 10</li><li>MIN_PRIORITY 1</li><li>NORM_PRIORITY 5 (默认)</li></ul><h1 id="多线程运行问题"><a class="markdownIt-Anchor" href="#多线程运行问题"></a> 多线程运行问题</h1><ul><li>各个线程是通过竞争CPU时间获得运行机会的</li><li>各线程什么时候得到CPU时间，占用多久，是不可预测的</li><li>一个正在运行的线程在什么地方被暂停是不确定的</li></ul><h2 id="同步"><a class="markdownIt-Anchor" href="#同步"></a> 同步</h2><ul><li>synchronized 可以被用在<ul><li>成员方法</li><li>静态方法</li><li>语句块</li></ul></li></ul><h2 id="线程间通信"><a class="markdownIt-Anchor" href="#线程间通信"></a> 线程间通信</h2><ul><li>生产者 - 消费者 模型</li><li>wait()方法，终端方法的执行，是线程等待</li><li>notify()方法，唤醒处于等待的某一个线程，使其结束等待</li><li>notifyAll()方法，唤醒处于等待的所有线程，使它们结束等待</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是进程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是进程&quot;&gt;&lt;/a&gt; 什么是进程&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;进程是指可执行程序并存放在计算机存储器的一个指令序列，他是一个动态执行的过程&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=</summary>
      
    
    
    
    
    <category term="Java" scheme="http://hellcy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Collections</title>
    <link href="http://hellcy.github.io/2022/02/12/Java-Collections/"/>
    <id>http://hellcy.github.io/2022/02/12/Java-Collections/</id>
    <published>2022-02-11T15:17:40.000Z</published>
    <updated>2022-02-12T09:22:52.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h1><ul><li>无法预测存储数据的数量</li><li>同时存储具有一对一关系的数据</li><li>需要进行数据的增删</li><li>数据重复的问题</li></ul><h1 id="集合框架的体系结构"><a class="markdownIt-Anchor" href="#集合框架的体系结构"></a> 集合框架的体系结构</h1><h2 id="collection-类的对象"><a class="markdownIt-Anchor" href="#collection-类的对象"></a> Collection - 类的对象</h2><ul><li>List<ul><li>ArrayList</li></ul></li><li>Queue<ul><li>LinkedList</li></ul></li><li>Set<ul><li>HashSet</li></ul></li></ul><h2 id="map-key-value-pairs"><a class="markdownIt-Anchor" href="#map-key-value-pairs"></a> Map - key value pairs</h2><ul><li>HashMap</li></ul><h1 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h1><ul><li>List是元素有序并且可以重复的集合，成为序列</li><li>List可以精确的控制每个元素的插入位置，或删除某个位置的元素</li><li>List的两个主要实现是ArrayList和LinkedList</li></ul><h2 id="arraylist"><a class="markdownIt-Anchor" href="#arraylist"></a> ArrayList</h2><ul><li>ArrayList底层是由数组实现的</li><li>动态增长（倍增)，以满足应用程序的需求</li><li>在列表尾部插入或删除数据非常有效，增删中间部分的元素则不是非常高效</li><li>更适合查找和更新元素</li><li>ArrayList中的元素可以为null</li></ul><h1 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h1><ul><li>Set是元素无序并且不可以重复的集合</li></ul><h2 id="hashset"><a class="markdownIt-Anchor" href="#hashset"></a> HashSet</h2><ul><li>HashSet是Set的一个重要的实现类，</li><li>HashSet中的元素无序并且不可以重复</li><li>HashSet中只允许一个null元素</li><li>具有良好的存取和查找性能</li></ul><h2 id="迭代器-iterator"><a class="markdownIt-Anchor" href="#迭代器-iterator"></a> 迭代器 Iterator</h2><ul><li>Iterator接口可以以统一的方法对各种集合元素进行遍历</li><li>hasNext()方法检测集合中是否还有下一个元素</li><li>next()方法返回集合中的下一个元素</li></ul><h1 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h1><ul><li>Map中的数据是以key value的形式存储的</li><li>key value是以Entry类型的对象实例存在</li><li>可以通过key值快速得查找value</li><li>一个映射不能包含重复的key， value可以重复</li><li>每个key最多映射到一个value</li></ul><h2 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h2><ul><li>给予哈希表得Map实现</li><li>允许使用null值和null key</li><li>key值不允许重复</li><li>HashMap中的entry对象是无序排列得</li></ul><h1 id="集合排序"><a class="markdownIt-Anchor" href="#集合排序"></a> 集合排序</h1><ul><li>使用Collections类的sort()方法</li><li>使用Comparator和Comparable接口进行排序</li></ul><h2 id="comparator接口"><a class="markdownIt-Anchor" href="#comparator接口"></a> Comparator接口</h2><ul><li>强行对某个对象进行整体排序的比较函数</li><li>可以将comparator传递给sort方法 （如Collections.sort或者Arrays.sort）</li><li>int compare(T o1, T o2) 比较用来排序的两个参数<ul><li>if o1 &lt; o2, return negative integer</li><li>if o1 == o2, return 0</li><li>if o1 &gt; o2, return positive integer</li></ul></li></ul><h2 id="comparable接口"><a class="markdownIt-Anchor" href="#comparable接口"></a> Comparable接口</h2><ul><li>此接口强行对实现他的每个类的对象进行整体排序</li><li>这种排序被称为类的自然排序，类的compareTo方法被称为他的自然比较方法</li><li>对于集合，通过调用Collections.sort方法进行排序</li><li>对于数组，通过调用Arrays.sort方法进行排序</li><li>int compareTo(T o)<ul><li>该对象小于，等于或大于指定对象，则分别返回负整数，零或者正整数 （与之前的<code>int compare(T o1, T o2)</code>相同）</li></ul></li></ul><h2 id="comparator-和-comparable-的区别"><a class="markdownIt-Anchor" href="#comparator-和-comparable-的区别"></a> Comparator 和 Comparable 的区别</h2><table><thead><tr><th>Comparator</th><th>Comparable</th></tr></thead><tbody><tr><td>位于java.util包</td><td>位于java.lang包</td></tr><tr><td>在要比较的类的外部实现该接口，并且可以实现多个不同的Comparator</td><td>在要比较的类上实现该接口</td></tr><tr><td>调用sort方法时，要指定comparator的实现类</td><td>调用sort方法时，只需指定集合名即可</td></tr></tbody></table><h2 id="应用场景-2"><a class="markdownIt-Anchor" href="#应用场景-2"></a> 应用场景</h2><ul><li>如果一个类实现了comparable接口，还希望通过不同的方式进行排序，我们还可以定义额外的Comparator</li><li>Comparable会作为默认的排序方式，Comparator接口则作为一个扩展的排序方式</li></ul><h2 id="treeset"><a class="markdownIt-Anchor" href="#treeset"></a> TreeSet</h2><ul><li>TreeSet 是一个有序的集合，它支持自然排序个根据实现Comparable和Comparator接口进行排序</li><li>当TreeSet用来储存String或者Integer对象时，会按照他们的升序排列</li><li>TreeSet无法排列自定义类，元素需要实现Comparator或者Comparable来排序</li></ul><h1 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h1><ul><li><p>在Java中增加泛型之前，泛型程序设计使用继承来实现</p><ul><li>坏处<ul><li>需要强制转换</li><li>可向集合中添加任意类型的元素，存在风险</li></ul></li></ul></li><li><p>泛型的使用</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure><ul><li>Java SE7及以后的版本中，构造方法中的泛型可以省略</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="多态与泛型"><a class="markdownIt-Anchor" href="#多态与泛型"></a> 多态与泛型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Cat extends Animal &#123;&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Animal&gt; list &#x3D; new ArrayList&lt;Cat&gt;(); &#x2F;&#x2F; not allowed</span><br><span class="line"></span><br><span class="line">List&lt;Number&gt; numbers &#x3D; new ArrayList&lt;Integer&gt;(); &#x2F;&#x2F; not allowed</span><br></pre></td></tr></table></figure><ul><li>以上代码是不允许的， 变量声明的类型必须匹配传递给实际对象的类型</li></ul><h2 id="自定义泛型类"><a class="markdownIt-Anchor" href="#自定义泛型类"></a> 自定义泛型类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class NumGeneric&lt;T&gt; &#123;</span><br><span class="line">  private T num;</span><br><span class="line"></span><br><span class="line">  public T getNum() &#123;</span><br><span class="line">    return num;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setNum(T num) &#123;</span><br><span class="line">    this.num &#x3D; num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; generic class with two generic types</span><br><span class="line">public class TwoNumGeneric&lt;A, B&gt; &#123;</span><br><span class="line">  private A num1;</span><br><span class="line">  private B num2;</span><br><span class="line"></span><br><span class="line">  public TwoNumGeneric(A num1, B num2) &#123;</span><br><span class="line">    this.num1 &#x3D; num1;</span><br><span class="line">    this.num2 &#x3D; num2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public A getNum1() &#123;</span><br><span class="line">    return num1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setNum1(A num1) &#123;</span><br><span class="line">    this.num1 &#x3D; num1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public B getNum2() &#123;</span><br><span class="line">    return num2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setNum2(B num2) &#123;</span><br><span class="line">    this.num2 &#x3D; num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义泛型方法"><a class="markdownIt-Anchor" href="#自定义泛型方法"></a> 自定义泛型方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class GenericMethod &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; &lt;T&gt; between public and void declare that this is a generic method</span><br><span class="line">  public &lt;T&gt; void printValue(T t) &#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;应用场景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#应用场景&quot;&gt;&lt;/a&gt; 应用场景&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;无法预测存储数据的数量&lt;/li&gt;
&lt;li&gt;同时存储具有一对一关系的数据&lt;/li&gt;
&lt;li&gt;需要进行数据的增删&lt;/li&gt;
</summary>
      
    
    
    
    
    <category term="Java" scheme="http://hellcy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Exceptions</title>
    <link href="http://hellcy.github.io/2022/02/11/Java-Exceptions/"/>
    <id>http://hellcy.github.io/2022/02/11/Java-Exceptions/</id>
    <published>2022-02-10T23:51:36.000Z</published>
    <updated>2022-02-12T12:21:13.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是异常"><a class="markdownIt-Anchor" href="#什么是异常"></a> 什么是异常</h1><ul><li>错误在我们编写程序的过程中会经常发生，包括编译期间和运行期间的错误</li><li>在程序运行过程中，意外发生的情况，背离我们程序本身意图的表现，都可以理解为异常</li></ul><h1 id="异常分类"><a class="markdownIt-Anchor" href="#异常分类"></a> 异常分类</h1><ul><li>Throwable<ul><li>Error<ul><li>OutOfMemoryError</li><li>ThreadDeath</li><li>…</li></ul></li><li>Exception<ul><li>程序本身可以处理的异常</li><li>unchecked exception （runtime exception）<ul><li>NullPointerException</li><li>ArrayIndexOutOfBoundsException</li><li>…</li></ul></li><li>checked exception<ul><li>IOException</li><li>SQLException</li><li>…</li></ul></li></ul></li></ul></li></ul><h1 id="捕获异常"><a class="markdownIt-Anchor" href="#捕获异常"></a> 捕获异常</h1><ul><li>对于运行时异常，错误或可查异常，Java技术所要求的异常处理方式有所不同</li><li>对于可查异常必须捕捉，或者声明抛出</li><li>允许忽略不可查的RuntimeException 和 Error</li></ul><h1 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h1><ul><li>通过5个关键字来实现： try, catch, finally, throw, throws</li></ul><h2 id="捕获异常-2"><a class="markdownIt-Anchor" href="#捕获异常-2"></a> 捕获异常</h2><ul><li>try: 执行可能产生异常的代码</li><li>catch: 捕获异常</li><li>finally: 无论是否发生异常，总是执行的代码</li></ul><h2 id="声明异常"><a class="markdownIt-Anchor" href="#声明异常"></a> 声明异常</h2><ul><li>throws: 声明可能要抛出的异常</li></ul><h2 id="抛出异常"><a class="markdownIt-Anchor" href="#抛出异常"></a> 抛出异常</h2><ul><li>手动抛出异常</li></ul><h2 id="try-catch-finally"><a class="markdownIt-Anchor" href="#try-catch-finally"></a> try catch finally</h2><ul><li>try之后可以接零个或多个catch， 如果没有catch，则必须接一个finally</li></ul><h2 id="throw-throws"><a class="markdownIt-Anchor" href="#throw-throws"></a> throw throws</h2><ul><li>可以通过throws声明将要抛出何种类型的异常， 通过throw将产生的异常抛出</li></ul><h1 id="throws"><a class="markdownIt-Anchor" href="#throws"></a> throws</h1><ul><li>如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用throws子句来声明抛出异常</li><li>throws语句用在方法定义时，生命该方法要抛出的异常类型</li><li>当方法抛出异常列表中的异常时，方法将不对这些类型及其子类类型的异常做处理，而抛向方法的调用者，由它去处理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int divideIntegers(int a, int b) throws Exception &#123;</span><br><span class="line">    return a &#x2F; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        int answer &#x3D; divideIntegers(5, 10);</span><br><span class="line">    &#125; catch(ArithmeticException e) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; catch(InputMismatchException e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; catch(Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="throw"><a class="markdownIt-Anchor" href="#throw"></a> throw</h1><ul><li>throw用来抛出一个异常</li><li>抛出的只能够是可抛出类throwable或者其子类的实例对象</li><li>自己抛出的异常，自己处理</li><li>抛出异常使用throws由调用者处理</li></ul><h1 id="自定义异常"><a class="markdownIt-Anchor" href="#自定义异常"></a> 自定义异常</h1><ul><li>使用Java内置的异常类可以描述在编程时出现的大部分异常情况</li><li>也可以通过自定义异常描述特定业务产生的异常类型</li><li>自定义异常就是定义一个类，去继承Throwable类或者它的子类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class CustomException extends Exception &#123;</span><br><span class="line">    public CustomExpcetion () &#123;</span><br><span class="line">        super(&quot;Custom exception message&quot;)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异常链"><a class="markdownIt-Anchor" href="#异常链"></a> 异常链</h1><ul><li><p>有时候我们会捕获一个异常后再抛出另一个异常</p></li><li><p>顾名思义就是：将异常发生的原因一个穿一个穿起来，把底层的异常信息传给上层，这样逐层抛出</p></li><li><p>新的异常可以保留原有异常的信息</p></li><li><p>构造方法的定义如下</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception(String mesasge, Throwable cause)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void methodOne() throws FirstException &#123;</span><br><span class="line">    throw new FirstException(&quot;first exception&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void methodTwo() throws SecondException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        methodOne();</span><br><span class="line">    &#125; catch (FirstException e) &#123;</span><br><span class="line">        throw new SecondException(&quot;Second Exception&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void methodThree() throws ThirdException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        methodTwo();</span><br><span class="line">    &#125; catch (SecondException e) &#123;</span><br><span class="line">        ThridException exception &#x3D; new ThirdException(&quot;third exception&quot;);</span><br><span class="line">        exception.initCause(e); &#x2F;&#x2F; initCause是Exception中的另外一个成员方法，用于添加cause，原有异常的信息</span><br><span class="line">        throw exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是异常&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是异常&quot;&gt;&lt;/a&gt; 什么是异常&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;错误在我们编写程序的过程中会经常发生，包括编译期间和运行期间的错误&lt;/li&gt;
&lt;li&gt;在程序运行过程中，意外发生的</summary>
      
    
    
    
    
    <category term="Java" scheme="http://hellcy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Polymorphism</title>
    <link href="http://hellcy.github.io/2022/02/10/Java-Polymorphism/"/>
    <id>http://hellcy.github.io/2022/02/10/Java-Polymorphism/</id>
    <published>2022-02-10T05:16:18.000Z</published>
    <updated>2022-02-12T12:20:50.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译时多态"><a class="markdownIt-Anchor" href="#编译时多态"></a> 编译时多态</h1><ul><li>设计时多态方法重载</li></ul><h1 id="运行时多态"><a class="markdownIt-Anchor" href="#运行时多态"></a> 运行时多态</h1><ul><li>程序运行时动态决定调用那个方法</li></ul><h1 id="必要条件"><a class="markdownIt-Anchor" href="#必要条件"></a> 必要条件</h1><ol><li>满足继承关系</li><li>父类引用指向子类对象</li></ol><h1 id="向上转型"><a class="markdownIt-Anchor" href="#向上转型"></a> 向上转型</h1><ul><li>父类引用指向子类实例，可以调用子类重写父类的方法以及父类派生的方法，无法调用子类独有的方法</li><li>父类中的静态方法无法被子类重写，所以向上转型之后，只能调用到父类原有的静态方法</li></ul><h1 id="向下转型"><a class="markdownIt-Anchor" href="#向下转型"></a> 向下转型</h1><ul><li>子类引用指向父类对象，此处可以使用<code>instanceof</code>进行检查，避免类型转换时的安全性问题</li><li>可以调用子类独有的方法</li></ul><h1 id="抽象类-abstract-class"><a class="markdownIt-Anchor" href="#抽象类-abstract-class"></a> 抽象类 abstract class</h1><ul><li>限制实例化</li><li>只能被继承</li><li>应用场景： 某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法</li></ul><h1 id="抽象方法-abstract-method"><a class="markdownIt-Anchor" href="#抽象方法-abstract-method"></a> 抽象方法 abstract method</h1><ul><li>不能有方法体</li><li>必须由子类实现</li><li>子类如果没有重写父类的所有抽象方法，则也要定义为抽象类</li></ul><h1 id="接口-interface"><a class="markdownIt-Anchor" href="#接口-interface"></a> 接口 Interface</h1><ul><li>当多个类具有相同能力的时候，可以使用接口抽象出相同的能力</li><li>接口定义了某一批类所需要遵守的规范</li><li>接口不关心这些类的内部数据，也不关心这些类里的方法的实现细节，它只规定这些类里必须提供某些方法</li><li>接口方法可以不写<code>abstract</code>关键字，并且默认为public的访问权限</li><li>当类实现接口时，需要去实现接口中的所有抽象方法，否则需要将该类设置为抽象类</li><li>接口中可以定义常量，默认为<code>public static final</code></li></ul><h2 id="默认方法"><a class="markdownIt-Anchor" href="#默认方法"></a> 默认方法</h2><ul><li>自JDK1.8之后，接口中可以存在默认方法，使用<code>default</code>关键字定义</li><li>默认方法可以带方法体，子类实现接口时可以不用实现默认方法</li><li>子类可以重写默认方法，并可以通过接口的引用调用</li></ul><h2 id="静态方法"><a class="markdownIt-Anchor" href="#静态方法"></a> 静态方法</h2><ul><li>自JDK1.8之后，接口中可以存在静态方法，使用<code>static</code>关键字定义</li><li>静态方法可以带方法体，子类可以通过使用接口名访问接口的静态方法</li></ul><h2 id="多重实现"><a class="markdownIt-Anchor" href="#多重实现"></a> 多重实现</h2><ul><li>子类可以继承一个父类，但是可以实现多个接口</li><li>当多个接口中具有相同签名的方法时，子类需要重写方法</li><li>当父类和接口具有相同签名的方法时，父类方法具有优先权</li><li>当父类和接口具有相同名字的变量时，子类需要重新定义该变量，父类中的变量不具有优先权</li></ul><h2 id="接口的继承"><a class="markdownIt-Anchor" href="#接口的继承"></a> 接口的继承</h2><ul><li>接口也可以实现继承关系</li><li>接口可以继承多个父接口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface ParentOne &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface ParentTwo &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Child extends ParentOne, ParentTwo &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h1><ul><li>内部类提供了更好的封装，不允许其他外部类访问内部类的信息</li></ul><h2 id="成员内部类"><a class="markdownIt-Anchor" href="#成员内部类"></a> 成员内部类</h2><ul><li>最常见的内部类，也称为普通内部类</li><li>内部类在外部使用时，无法直接实例化，需要借由外部类信息才能完成实例化</li><li>内部类的访问修饰符，可以是任意的，但是访问权限会受到修饰符的影响</li><li>内部类可以直接访问外部类的成员（包括成员属性和成员方法），如果出现同名属性，优先访问内部类中定义的</li><li>外部类访问内部类的信息需要通过内部类的实例，无法直接访问</li><li>内部类编译后得class文件名：外部类$内部类.class</li></ul><h3 id="获取内部类对象实例"><a class="markdownIt-Anchor" href="#获取内部类对象实例"></a> 获取内部类对象实例</h3><ol><li>new 外部类.new 内部类</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.Heart myHeart &#x3D; new Person().new Heart();</span><br></pre></td></tr></table></figure><ol start="2"><li>外部类对象.new 内部类</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myHeart &#x3D; myPerson.new Heart();</span><br></pre></td></tr></table></figure><ol start="3"><li>外部类对象.获取方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myHeart &#x3D; myPerson.getHeart();</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a class="markdownIt-Anchor" href="#静态内部类"></a> 静态内部类</h2><ul><li>静态内部类中，只能直接访问外部类的静态成员</li><li>需要使用外部类的实例对象来访问非静态成员</li><li>访问静态内部类对象实例时，可以不依赖于外部类对象</li></ul><h3 id="获取静态内部类实例"><a class="markdownIt-Anchor" href="#获取静态内部类实例"></a> 获取静态内部类实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.Heart myHeart &#x3D; new Person.Heart();</span><br></pre></td></tr></table></figure><h2 id="方法内部类"><a class="markdownIt-Anchor" href="#方法内部类"></a> 方法内部类</h2><ul><li>定义在外部类方法中的内部类，也成为局部内部类</li><li>方法内部类中无法定义静态成员</li><li>类中可以使用final，abstract成员</li><li>和方法内部成员使用规则一样，class前面不可以添加public，private，protected，static等关键字</li></ul><h2 id="匿名内部类"><a class="markdownIt-Anchor" href="#匿名内部类"></a> 匿名内部类</h2><ul><li>将类的定义和类的创建放在一起完成，程序只会用到一次类的实例，所以类名无关紧要</li><li>对于抽象类Person来说，如果我们想调用其中的抽象方法，一种做法是创建一个实现read方法的子类</li><li>但是如果这个子类只会被用到一次，那这个子类的名字就不重要，就可以使用匿名内部类来解决</li><li>无法使用private，public，protected，static修饰</li><li>无法编写构造方法，但是可以添加初始化代码块</li><li>不能出现静态成员</li><li>可以实现接口也可以继承父类，但是不能同时</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Person &#123;</span><br><span class="line">    public abstract void read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PersonTest &#123;</span><br><span class="line">    public void getRead(Person person) &#123;</span><br><span class="line">        person.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        PersonTest personTest &#x3D; new PersonTest();</span><br><span class="line"></span><br><span class="line">        personTest.getRead(new Person() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void read() &#123;</span><br><span class="line">                System.out.println(&quot;implement read method in Person parent abstract class&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名类的例子"><a class="markdownIt-Anchor" href="#匿名类的例子"></a> 匿名类的例子</h3><ul><li><p>在我们使用comparator对Collections进行排序的时候可以使用匿名类来省去创建子类的过程</p></li><li><p>不使用匿名类对List排序</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; create a child class implements parent Comparator</span><br><span class="line">public class CustomComparator implements Comparator&lt;String&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(String o1, String o2) &#123;</span><br><span class="line">        return o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class testComparator() &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; use CustomComparator to sort list</span><br><span class="line">    Collections.sort(list, new CustomComparator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用匿名类对list排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class testComparator() &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Collections.sort(list, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">        public int compare(String o1, String o2) &#123;</span><br><span class="line">            return o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自Java1.8以后，可以使用lambda expression来省去方法名，匿名方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class testComparator() &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Collections.sort(list, (x, y) -&gt; x.compareTo(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为上面的匿名方法和String里面定义的compareTo方法一样，我们可以使用method reference来更加简化代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class testComparator() &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Collections.sort(list, String::compareTo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编译时多态&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#编译时多态&quot;&gt;&lt;/a&gt; 编译时多态&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;设计时多态方法重载&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;运行时多态&quot;&gt;&lt;a class=&quot;markdownIt-</summary>
      
    
    
    
    
    <category term="Java" scheme="http://hellcy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Design Pattern - Singleton in Java</title>
    <link href="http://hellcy.github.io/2022/02/09/Design-Pattern-Singleton-in-Java/"/>
    <id>http://hellcy.github.io/2022/02/09/Design-Pattern-Singleton-in-Java/</id>
    <published>2022-02-09T06:26:19.000Z</published>
    <updated>2022-02-10T14:39:24.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目的"><a class="markdownIt-Anchor" href="#目的"></a> 目的</h1><ul><li>使得类的一个对象成为该类系统中唯一的实例</li></ul><h1 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h1><ul><li>一个类有且仅有一个实例，并且自行实例化向整个系统提供</li></ul><h1 id="要点"><a class="markdownIt-Anchor" href="#要点"></a> 要点</h1><ol><li>某个类只能有一个实例</li><li>必须自行创建实例</li><li>必须自行向这个系统提供这个实例</li></ol><h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1><ol><li>只提供私有的构造方法</li><li>含有一个该类的静态私有对象</li><li>提供一个静态的公有方法用于创建，获取静态私有对象</li></ol><ul><li>Create class instance when class is loaded</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonOne &#123;</span><br><span class="line">  &#x2F;&#x2F; private class constructor</span><br><span class="line">  private SingletonOne () &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; private static instance</span><br><span class="line">  private static SingletonOne INSTANCE &#x3D; new SingletonOne();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; return instance in public method</span><br><span class="line">  public static SingletonOne getInstance() &#123;</span><br><span class="line">    return INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; SingletonOne instance &#x3D; SingletonOne.getInstance();</span><br></pre></td></tr></table></figure><ul><li>Only create instance when the method is being called</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTwo &#123;</span><br><span class="line">  private SingletonTwo () &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static SingletonTwo INSTANCE &#x3D; null;</span><br><span class="line"></span><br><span class="line">  public static SingletonTwo getInstance() &#123;</span><br><span class="line">    if (INSTANCE &#x3D;&#x3D; null) INSTANCE &#x3D; new SingletonTwo();</span><br><span class="line">    return INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h1><ul><li>lazy loading 存在线程风险 1<ol><li>同步锁</li><li>双重校验锁</li><li>静态内部类</li><li>枚举</li></ol></li></ul><h1 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h1><ol><li>在内存中只有一个对象，节省内存空间</li><li>避免频繁地创建对象，提高性能</li><li>避免对共享资源的多重占用</li></ol><h1 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h1><ol><li>扩展比较困难</li><li>如果实例化后的对象长期不利用，系统将默认为垃圾进行回收，造成对象状态丢失</li></ol><h1 id="场景"><a class="markdownIt-Anchor" href="#场景"></a> 场景</h1><ol><li>创建对象时占用资源过多，但同时有需要用到该类对象</li><li>对系统内资源要求统一读写，如读写配置信息</li><li>当多个实例存在可能引起程序逻辑错误，如号码生成器 （ID）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目的&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目的&quot;&gt;&lt;/a&gt; 目的&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;使得类的一个对象成为该类系统中唯一的实例&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;定义&quot;&gt;&lt;a class=&quot;markdownIt-A</summary>
      
    
    
    
    
    <category term="Java" scheme="http://hellcy.github.io/tags/Java/"/>
    
    <category term="Design Patterns" scheme="http://hellcy.github.io/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>Elastic Search</title>
    <link href="http://hellcy.github.io/2022/01/02/Elastic-Search/"/>
    <id>http://hellcy.github.io/2022/01/02/Elastic-Search/</id>
    <published>2022-01-02T06:41:13.000Z</published>
    <updated>2022-02-10T14:39:24.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="basics"><a class="markdownIt-Anchor" href="#basics"></a> Basics</h1><ul><li>Nodes store the data that we add to ElasticSearch</li><li>A cluster is a collection of nodes</li><li>Data is stored as document which are JSON objects</li><li>Documents are grouped together with indices</li></ul><h2 id="the-purpose-of-sharding"><a class="markdownIt-Anchor" href="#the-purpose-of-sharding"></a> The purpose of sharding</h2><ul><li>mainly to be able to store more documents</li><li>to easier fit large indices onto nodes</li><li>improved performance<ul><li>parallelization of queries increases the throughput of an index</li></ul></li></ul><h2 id="configuring-the-number-of-shards"><a class="markdownIt-Anchor" href="#configuring-the-number-of-shards"></a> Configuring the number of shards</h2><ul><li>an index contains a single shard by default</li><li>increase the number of shards with the Split API</li><li>reduce the number of shards with the Shrink API</li><li>when changing the number of shards, new index will be created and documents in the old index will be migrated to the new index</li></ul><h2 id="replication"><a class="markdownIt-Anchor" href="#replication"></a> Replication</h2><ul><li><p>replication is configured at the index level</p></li><li><p>replication works by creating copies of shards, referred to as replica shards</p></li><li><p>a shard that has been replicated is called a primary shard</p></li><li><p>a primary shard and its replica shards are referred as a replication group</p></li><li><p>replica shards are a complete copy of a shard</p></li><li><p>a replica shard can serve search requests, exactly like its primary shard</p></li><li><p>the number of replicas can be configured at index creation</p></li><li><p>node can store multiple shards, and primary shard and replica shards will never be stored in the same node. So the data will NOT be lost if the node fails</p></li></ul><h2 id="snapshots"><a class="markdownIt-Anchor" href="#snapshots"></a> snapshots</h2><ul><li>ElasticSearch supports taking snapshots as backups</li><li>snapshots can be used to restore to a given point in time</li><li>snapshots can be taken at the index level, or for the entire cluster</li><li>use snapshots for backups, and replication for high availability and performance</li></ul><h2 id="increasing-query-throughput-with-replication"><a class="markdownIt-Anchor" href="#increasing-query-throughput-with-replication"></a> increasing query throughput with replication</h2><ul><li>replica shards of a replication group can serve different search requests simultaneously<ul><li>this increases the number of requests that can be handled at the same time</li></ul></li><li>ElasticSearch intelligently routes requests to the best shard</li><li>CPU parallelization (CPU has multiple cores now and can run queries on different threads at the same time) improves performance if multiple replica shards are stored on the same node</li></ul><h2 id="master-eligible-node"><a class="markdownIt-Anchor" href="#master-eligible-node"></a> Master-eligible node</h2><ul><li>the node may be elected as the cluster’s master node</li><li>a master node is responsible for creating and deleting indices, among others</li><li>may be used for having dedicated master nodes<ul><li>useful for large clusters</li><li>meaning that this master node will not be serving requests, only focusing on its own tasks</li></ul></li></ul><h2 id="data-node"><a class="markdownIt-Anchor" href="#data-node"></a> Data node</h2><ul><li>enables a node to store data</li><li>storing data includes performing queries related to that data, such as search queries</li><li>for relatively small clusters, this role is almost always enabled</li></ul><h1 id="managing-documents"><a class="markdownIt-Anchor" href="#managing-documents"></a> Managing Documents</h1><ul><li>Delete index</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE &#x2F;index_name</span><br></pre></td></tr></table></figure><ul><li>create index</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;index_name</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;number_of_shards&quot;: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="indexing-documents"><a class="markdownIt-Anchor" href="#indexing-documents"></a> indexing documents</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;products&#x2F;_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Coffee Maker&quot;,</span><br><span class="line">  &quot;price&quot;: 53,</span><br><span class="line">  &quot;in_stack&quot;: 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="retrieving-document-by-id"><a class="markdownIt-Anchor" href="#retrieving-document-by-id"></a> Retrieving document by ID</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;products&#x2F;_doc&#x2F;document_ID</span><br></pre></td></tr></table></figure><h2 id="updating-document"><a class="markdownIt-Anchor" href="#updating-document"></a> Updating document</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;products&#x2F;_update&#x2F;document_ID</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;new name&quot;,</span><br><span class="line">    &quot;new field&quot;: &quot;this is a new field&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="upserts"><a class="markdownIt-Anchor" href="#upserts"></a> Upserts</h2><ul><li>insert the new document if not exists, and run the script if the document exists</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;products&#x2F;_update&#x2F;101</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.in_stock++</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;upsert&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;name&quot;,</span><br><span class="line">    &quot;price&quot;: 399,</span><br><span class="line">    &quot;in_stock&quot;: 5</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="delete-document"><a class="markdownIt-Anchor" href="#delete-document"></a> Delete document</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE &#x2F;products&#x2F;_doc&#x2F;101</span><br></pre></td></tr></table></figure><h2 id="routing"><a class="markdownIt-Anchor" href="#routing"></a> Routing</h2><ul><li>routing is the process of resolving a shard for a document</li><li>the default routing strategy ensures that documents are distributed evenly</li></ul><h2 id="optimistic-concurrency-control"><a class="markdownIt-Anchor" href="#optimistic-concurrency-control"></a> Optimistic concurrency control</h2><ul><li>prevent overwriting documents inadvertently dur to concurrent operations</li><li>primary terms<ul><li>a way to distinguish between old and new primary shards</li><li>essentially a counter for how many times the primary shard has changed</li><li>the primary term is appended to write operations</li></ul></li><li>sequence numbers<ul><li>appended to write operations together with the primary term</li><li>essentially a counter that is incremented for each write operation</li><li>the primary shard increases the sequence number</li><li>enables ElasticSearch to order write operations</li></ul></li><li>sending write requests to ElasticSearch concurrently may overwrite changes made by other concurrent processes</li><li>we use the primary terms and sequence number fields</li><li>ElasticSearch will reject a write operation if it contains the wrong primary term or sequence number</li></ul><h2 id="updating-multiple-document"><a class="markdownIt-Anchor" href="#updating-multiple-document"></a> Updating multiple document</h2><ul><li>the query creates a snapshot to do optimistic concurrency control</li><li>search queries and bulk requests are sent to replication groups sequentially<ul><li>ElasticSearch retries these queries up to ten times</li><li>if the queries still fail, the whole query is aborted</li><li>any changes already made to documents, are NOT rolled back</li></ul></li><li>the API returns information about failures</li></ul><h1 id="mapping-and-analysis"><a class="markdownIt-Anchor" href="#mapping-and-analysis"></a> Mapping and Analysis</h1><ul><li>a field’s values are stored in one of several data structures<ul><li>the data structure depends on the field’s data type</li></ul></li><li>ensures efficient data access</li></ul><h2 id="inverted-indices"><a class="markdownIt-Anchor" href="#inverted-indices"></a> Inverted indices</h2><ul><li><p>mapping between terms (tags) and which documents contain them</p></li><li><p>outside the context of analyzers, we use the terminology ‘terms’</p></li><li><p>an inverted index is created for EACH text field</p></li><li><p>values for a text field are analyzed and the results are stored within an inverted index</p></li><li><p>each field has a dedicated inverted index</p></li><li><p>an inverted index is a mapping between terms and which documents contain them</p></li><li><p>terms are sorted alphabetically for performance reasons</p></li><li><p>created and maintained by Apache Lucene</p></li><li><p>inverted indices enable fast searches</p></li></ul><p>Note: for array of strings</p><ul><li>In ElasticSearch, there is no dedicated array data type, any field can contain zero or more values by default, however, all values in the array must be of the same data type</li><li>when adding a field dynamically, the first value in the array determines the field type</li><li>meaning for array of strings, ElasticSearch would have created a inverted index mapping table for it</li></ul><h2 id="keyword-data-type"><a class="markdownIt-Anchor" href="#keyword-data-type"></a> keyword data type</h2><ul><li><p>keyword fields are analyzed with the keyword analyzer</p></li><li><p>the keyword analyzer is an no-op analyzer</p><ul><li>it outputs the unmodified string as a single token</li><li>this token is then placed into the inverted index</li></ul></li><li><p>used for exact matching of values</p></li><li><p>typically used for filtering, aggregations, and sorting</p></li><li><p>for full-text searches, use the text data type instead</p></li></ul><h2 id="arrays"><a class="markdownIt-Anchor" href="#arrays"></a> Arrays</h2><ul><li>there is no such thing as an array data type</li><li>any field may contain zero or more values<ul><li>no configuration or mapping needed</li><li>simply supply an array when indexing a document</li></ul></li><li>how is the array stored in the ElasticSearch internally?<ul><li>e.g. if it is an array of strings</li><li>the strings are simply concatenated before being analyzed</li><li>and the resulting tokens are stored within an inverted index as normal String data type</li></ul></li></ul><h2 id="dates"><a class="markdownIt-Anchor" href="#dates"></a> Dates</h2><ul><li>specified in one of the three ways<ul><li>specially formatted strings</li><li>milliseconds since the epoch</li><li>seconds since the epoch</li></ul></li><li>epoch refers to the 1st of Jan 1970</li><li>custom formats are supported</li></ul><h3 id="how-date-fields-are-stored"><a class="markdownIt-Anchor" href="#how-date-fields-are-stored"></a> How date fields are stored</h3><ul><li>stored internally as milliseconds since the epoch</li><li>any valid value that you supply at index time is converted to a long value internally</li><li>dates are converted to the UTC timezone</li><li>the same date conversion happens for search queries too</li></ul><h2 id="missing-fields"><a class="markdownIt-Anchor" href="#missing-fields"></a> Missing fields</h2><ul><li>all fields are ElasticSearch are optional</li><li>you can leave out a field when indexing documents</li><li>unlike relational databases when you need to allow NULL values</li><li>some integrity checks need to be done at the application level<ul><li>e.g. having required fields</li></ul></li><li>adding a field mapping does not make a field required</li><li>searches automatically handle missing fields</li></ul><h2 id="stemming-and-stop-words"><a class="markdownIt-Anchor" href="#stemming-and-stop-words"></a> Stemming and stop words</h2><h3 id="stemming"><a class="markdownIt-Anchor" href="#stemming"></a> Stemming</h3><ul><li>reduces words to their root form<ul><li>e.g. loved -&gt; love</li><li>drinking -&gt; drink</li></ul></li></ul><h3 id="stop-words"><a class="markdownIt-Anchor" href="#stop-words"></a> stop words</h3><ul><li>words that are filtered out during the text analysis<ul><li>common words such as ‘a’, ‘the’, ‘at’, ‘of’, ‘on’ etc…</li></ul></li><li>they provide little to no value to the relevance scoring</li><li>fairly common to remove such words<ul><li>less common in ElasticSearch today than in the past</li><li>the relevance algorithm has been improved significantly</li></ul></li><li>not removed by default</li></ul><h2 id="analyzer"><a class="markdownIt-Anchor" href="#analyzer"></a> Analyzer</h2><h3 id="standard-analyzer"><a class="markdownIt-Anchor" href="#standard-analyzer"></a> Standard analyzer</h3><ul><li>splits text at word boundaries and removes punctuation<ul><li>done by the standard tokenizer</li></ul></li><li>lowercase letter with the lowercase token filter</li><li>contains the stop token filter (for removing stop words, disabled by default)</li></ul><h3 id="simple-analyzer"><a class="markdownIt-Anchor" href="#simple-analyzer"></a> Simple analyzer</h3><h3 id="whitespace-analyzer"><a class="markdownIt-Anchor" href="#whitespace-analyzer"></a> whitespace analyzer</h3><h3 id="keyword-analyzer"><a class="markdownIt-Anchor" href="#keyword-analyzer"></a> keyword analyzer</h3><h3 id="pattern-analyzer"><a class="markdownIt-Anchor" href="#pattern-analyzer"></a> pattern analyzer</h3><ul><li>a regular expression is used to match token separators<ul><li>it should match whatever should split the text into tokens</li></ul></li><li>this analyzer is very flexible</li><li>the default pattern matches all non-word characters</li><li>lowercase letters by default</li></ul><h1 id="introduction-to-searching"><a class="markdownIt-Anchor" href="#introduction-to-searching"></a> Introduction to Searching</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;product&#x2F;default&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>search queries will hit the coordinating node first, and this node will broadcast the query to all the other nodes, they will fetch the result and combine them together and return it.</li></ul><h2 id="term-level-queries"><a class="markdownIt-Anchor" href="#term-level-queries"></a> term level queries</h2><ul><li>search for exact matches, case sensitive, searching the inverted index, not the original document</li><li>term level queries are more suited for searching static values, like enums</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;basics&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#basics&quot;&gt;&lt;/a&gt; Basics&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Nodes store the data that we add to ElasticSearch&lt;/li&gt;</summary>
      
    
    
    
    
    <category term="Elastic Search" scheme="http://hellcy.github.io/tags/Elastic-Search/"/>
    
  </entry>
  
  <entry>
    <title>Dot net + React</title>
    <link href="http://hellcy.github.io/2021/12/09/Dot-net-React/"/>
    <id>http://hellcy.github.io/2021/12/09/Dot-net-React/</id>
    <published>2021-12-09T12:17:52.000Z</published>
    <updated>2022-02-10T14:39:24.300Z</updated>
    
    
    
    
    
    <category term=".NET" scheme="http://hellcy.github.io/tags/NET/"/>
    
    <category term="React" scheme="http://hellcy.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Spring Framework</title>
    <link href="http://hellcy.github.io/2021/11/05/Spring-Framework/"/>
    <id>http://hellcy.github.io/2021/11/05/Spring-Framework/</id>
    <published>2021-11-04T13:06:37.000Z</published>
    <updated>2022-02-10T14:39:24.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-framework-stereotypes"><a class="markdownIt-Anchor" href="#spring-framework-stereotypes"></a> Spring Framework Stereotypes</h1><ul><li>Stereotype - a fixed general image or ser of characteristics which represent a particular type of person or thing</li><li>Spring Stereotypes are <code>class</code> level annotations used to define Spring Beans<ul><li><strong>when classes annotated with Spring Stereotypes are detected via the component scan, an instance of the class will be added to the Spring context</strong></li></ul></li><li>Available Spring Stereotypes<ul><li><code>@Component</code></li><li><code>@Controller</code></li><li><code>@RestController</code></li><li><code>@Repository</code></li><li><code>@Service</code></li></ul></li></ul><table><thead><tr><th>Annotation</th><th>Description</th></tr></thead><tbody><tr><td>@Component</td><td>Indicates that an annotated class is a component and it will be created as a bean</td></tr><tr><td>@Controller</td><td>indicates that an annotated class has the role of a Spring MVC controller</td></tr><tr><td>@RestController</td><td>convenience annotation which extends @Controller and @ResponseBody</td></tr><tr><td>@Repository</td><td>indicates class is a Repository, a mechanism for encapsulating storage, retrieval, and search behavior which emulates a collection of objects</td></tr><tr><td>@Service</td><td>indicates that an annotated class is a Service, an operation offered as an interface that stands alone in the model, with no encapsulated state</td></tr></tbody></table><h1 id="spring-component-scan"><a class="markdownIt-Anchor" href="#spring-component-scan"></a> Spring Component Scan</h1><ul><li>Spring Beans defined with Spring Stereotypes are detected with Spring component scan</li><li>On startup, Spring is told to scan packages for classes with Spring Stereotype annotations</li><li>This configuration is Spring Framework specific, not Spring Boot</li><li>Spring Boot’s auto configuration will tell Spring to perform a component scan of the package of the main class<ul><li>this includes all sub packages of the main class package</li></ul></li><li>when using Spring Boot, if class is outside of the main class package tree, you must declare the package scan manually</li></ul><h1 id="spring-bean-scopes"><a class="markdownIt-Anchor" href="#spring-bean-scopes"></a> Spring Bean Scopes</h1><ul><li><code>Singleton</code> - (default) only one instance of the bean is created in the IoC container</li><li><code>Prototype</code> - A new instance is created each time the bean is requested</li><li><code>Request</code> - For web app, a single instance per http request, only valid in the context of a web aware Spring applicationContext</li><li><code>Session</code> - for web app, a single instance per http session, only valid in the context of a web aware Spring applicationContext</li><li><code>Global-session</code> - a single instance per global session, typically only used in a Portlet context, only valid in the context of a web aware Spring applicationContext</li><li><code>Application</code> - bean is scoped to the lifecycle of a ServletContext, only valid in the context of web aware</li><li><code>WebSocket</code> - scopes a single bean definition to the lifecycle of a WebSocket, only valid in the context of a web aware Spring applicationContext</li><li><code>Custom Scope</code> - Spring Scopes are extensible, and you can define your own scope by implementing Spring’s scope interface</li></ul><h2 id="declaring-bean-scope"><a class="markdownIt-Anchor" href="#declaring-bean-scope"></a> Declaring Bean Scope</h2><ul><li>No declaration needed for singleton scope</li><li>in Java configuration use <code>@Scope</code> annotation</li><li>in XML configuration file scope is an XML attribute of the bean tag</li><li>99% of the time singleton scope is fine</li></ul><h1 id="external-properties"><a class="markdownIt-Anchor" href="#external-properties"></a> External Properties</h1><ul><li>Why use External Properties?<ul><li>hard coding values which can change is considered a bad practice</li><li>makes your application rigid and hard to change</li><li>you want your application to be portable<ul><li>deployment artifact (jar, war) should be deployable to different environments</li></ul></li></ul></li><li>what can change?<ul><li>usernames, passwords, urls, API keys, paths, queue names etc…</li></ul></li></ul><h2 id="which-property-files-to-use"><a class="markdownIt-Anchor" href="#which-property-files-to-use"></a> which property files to use</h2><ul><li>using application.properties or application.yml in packaged JAR or WAR</li><li>using profile specific properties or YAML files for profile specific properties</li><li>for deployments, override properties that change with environment variables<ul><li>typically 70 - 80% of values do not change, only override what is needed</li><li>environment variables offer a secure way of seeing sensitive values such as passwords</li></ul></li></ul><h2 id="properties-setting-hierarchy-from-low-to-high"><a class="markdownIt-Anchor" href="#properties-setting-hierarchy-from-low-to-high"></a> Properties Setting Hierarchy (from low to high)</h2><ol><li>application.properties</li><li>environment variables</li><li>command line variables</li></ol><h1 id="thymeleaf"><a class="markdownIt-Anchor" href="#thymeleaf"></a> Thymeleaf</h1><ul><li>Thymeleaf is a Java template engine producing XML, XHTML and HTML5</li><li>Thymeleaf is a replacement of JSPs</li><li>Thymeleaf is a natural template engine (the templates are viewable in a web browser)</li><li>is not tied to web environment (can be used for producing HTML for emails)</li><li>Thymeleaf is not a web framework</li></ul><h1 id="request-methods"><a class="markdownIt-Anchor" href="#request-methods"></a> Request Methods</h1><ul><li>GET<ul><li>is a request for a resource (html file, javascript file, image, etc…)</li><li>is used when you visit a website</li></ul></li><li>HEAD<ul><li>is like GET, but only asks for meta information without the body</li></ul></li><li>POST<ul><li>is used to post data to the server</li><li>typical use case for POST is to post form data to the server (like a checkout form)</li><li>POST is a create request</li></ul></li><li>PUT<ul><li>is a request for the enclosed entity be stored at the supplied URI, if the entity exists, it is expected to be updated</li><li>PUT is a create OR update request</li></ul></li><li>DELETE<ul><li>is a request to delete the specified resource</li></ul></li><li>TRACE<ul><li>will echo the received request, can be used to see if request was altered by intermediate servers</li></ul></li><li>OPTIONS<ul><li>returns the HTTP methods supported by the server for the specified URL</li></ul></li></ul><h2 id="safe-methods"><a class="markdownIt-Anchor" href="#safe-methods"></a> Safe methods</h2><ul><li>safe methods are considered safe to use because they only fetch information and do not cause changes on the server</li><li>the safe methods are: GET, HEAD, OPTIONS, and TRACE</li></ul><h2 id="idempotent-methods"><a class="markdownIt-Anchor" href="#idempotent-methods"></a> Idempotent methods</h2><ul><li>a quality of an action such that repetitions of the action have no further effect on the outcome</li><li>PUT and DELETE are Idempotent methods</li><li>safe methods (GET, HEAD, OPTIONS and TRACE) are also Idempotent</li><li>being truly idempotent is not enforced by the protocol</li></ul><h2 id="non-idempotent-methods"><a class="markdownIt-Anchor" href="#non-idempotent-methods"></a> Non-Idempotent methods</h2><ul><li>POST is NOT idempotent</li><li>multiple POSTs are likely to create multiple resources</li><li>Ever seen websites asking you to click submit only once?</li></ul><h2 id="http-status-codes"><a class="markdownIt-Anchor" href="#http-status-codes"></a> HTTP Status Codes</h2><ul><li>100 series are information in nature</li><li>200 series indicate successful request<ul><li>200 Okay, 201 Created, 204 Accepted</li></ul></li><li>300 series are redirections<ul><li>301 Moved Permanently</li></ul></li><li>400 series are client errors<ul><li>400 Bad Request, 401 Not Authorized, 404 Not Found</li></ul></li><li>500 series are server side errors<ul><li>500 Internel Server Error, 503 Service Unavailable</li></ul></li></ul><h1 id="developer-tools"><a class="markdownIt-Anchor" href="#developer-tools"></a> Developer Tools</h1><ul><li>added to project via artifact ‘spring-boot-devtools’</li><li>developer tools are automatically disabled when running a packaged application</li><li>by default, not included in repackaged archives</li></ul><h2 id="features"><a class="markdownIt-Anchor" href="#features"></a> Features</h2><ul><li>by default you need to select Build -&gt; Make project</li><li>there is an advanced setting you can change to make this more seamless</li></ul><h2 id="template-caching"><a class="markdownIt-Anchor" href="#template-caching"></a> Template caching</h2><ul><li>by default templates are cached for performance</li><li>but caching will require a container restart to refresh the cache</li><li>developer tools will disable template caching so the restart is not required to see changes</li></ul><h2 id="livereload"><a class="markdownIt-Anchor" href="#livereload"></a> LiveReload</h2><ul><li>LiveReload is a technology to automatically trigger a browser refresh when resources are changed</li><li>Spring boot developer tools includes a LiveReload server</li></ul><h1 id="entity-relationships"><a class="markdownIt-Anchor" href="#entity-relationships"></a> Entity Relationships</h1><ul><li>One to One<ul><li>One entity is related to one other entity</li></ul></li><li>One to Many<ul><li>One entity is related to many entities (List, Set, Map, SortedSet, SortedMap)</li></ul></li><li>Many to One<ul><li>the inverse relationship of one to many</li></ul></li><li>Many to Many<ul><li>many entities are related to many entities</li><li>each has a list or set reference to the other</li><li>a join table us used to define the relationships (mapping table)</li></ul></li></ul><h2 id="unidirectional-vs-bidirectional"><a class="markdownIt-Anchor" href="#unidirectional-vs-bidirectional"></a> Unidirectional vs Bidirectional</h2><ul><li>Unidirectional is one way<ul><li>mapping is only done one way, one side of the relationship will not know about the other</li></ul></li><li>Bidirectional is two way<ul><li>both sides know about each other</li><li>generally recommended to use bidirectional, since you can navigate the object graph in either direction</li></ul></li></ul><h2 id="owning-side"><a class="markdownIt-Anchor" href="#owning-side"></a> Owning side</h2><ul><li>the Owning side in the relationship will hold the foreign key in the database</li><li>one to one is the side where the foreign key is specified</li><li>one to many and many to one is the <code>Many</code> side</li><li>mappedBy is used to define the field with <code>owns</code> the reference of the relationship</li></ul><h2 id="fetch-type"><a class="markdownIt-Anchor" href="#fetch-type"></a> Fetch type</h2><ul><li>Lazy - data is not required until referenced</li><li>Eager - data is queried up front</li></ul><h2 id="jpa-cascade-types"><a class="markdownIt-Anchor" href="#jpa-cascade-types"></a> JPA Cascade Types</h2><ul><li>JPA Cascade types control how state changes are cascaded from parent objects to child objects</li><li>Types<ul><li>PERSIS</li><li>MERGE</li><li>REFRESH</li><li>REMOVE</li><li>DETACH</li><li>ALL</li></ul></li><li>by default, no operations are cascaded</li></ul><h2 id="embeddable-types"><a class="markdownIt-Anchor" href="#embeddable-types"></a> Embeddable Types</h2><ul><li>JPA / Hibernate support embeddable types</li><li>these are used to define a common set of properties</li><li>for example, an order might have a billing address and a shipping address</li><li>an embeddable type could be used for the address properties for reuse</li></ul><h2 id="inheritance"><a class="markdownIt-Anchor" href="#inheritance"></a> Inheritance</h2><ul><li>mappedSuperclass - entities inherit from a super class, a database table IS NOT created for the super class</li><li>Single Table - default - one table is used for all subclasses</li><li>Joined Table - base class and subclasses have their own tables, fetching subclass entities require a join to the parent table (subclasses will not have the common properties from the parent class)</li><li>Table Per Class - each subclass has its own table (no table for parent class. common properties will exist in all subclasses)</li></ul><h2 id="create-and-update-timestamps"><a class="markdownIt-Anchor" href="#create-and-update-timestamps"></a> Create and Update Timestamps</h2><ul><li>often a best practice to use create and update timestamps on your entities for audit purposes</li><li>JPA supports <code>@PrePersist</code> and <code>@PreUpdate</code> which can be used for support audit timestamps via JPA lifecycle callbacks</li><li>hibernate provides <code>@CreationTimestamp</code> and <code>@UpdateTimestamp</code></li></ul><h1 id="hibernate-ddl-auto"><a class="markdownIt-Anchor" href="#hibernate-ddl-auto"></a> Hibernate DDL Auto</h1><ul><li>DDL - Data Definition Language</li><li>DML - Data Manipulation Language</li><li>Hibernate property is set by the Spring property</li><li>options are<ul><li>none</li><li>validate - check if there is any table or columns that are missing</li><li>update - find missing table and columns and update the existing DB, not good for PROD environment</li><li>create - create the DB</li><li>create-drop - create the DB and drop the DB when application instance stops running.</li></ul></li><li>Spring boot will use create-drop for embedded databases (HSQL, H2, Derby) or none</li></ul><h2 id="ddl-vs-dml"><a class="markdownIt-Anchor" href="#ddl-vs-dml"></a> DDL vs DML</h2><ul><li>DDL is used to define database structures such as tables and indexes, while DML is used with data operations such as inserts and updates</li></ul><h2 id="initialize-with-hibernate"><a class="markdownIt-Anchor" href="#initialize-with-hibernate"></a> Initialize with Hibernate</h2><ul><li>data can be loaded from <code>import.sql</code>, this is a file that can be created in the root path</li><li>Hibernate feature, not Spring specific</li><li>must be on root of class path</li><li>only executed if Hinernate’s DDL auto property is set to <code>create</code> or <code>create-drop</code></li></ul><h2 id="spring-jdbc"><a class="markdownIt-Anchor" href="#spring-jdbc"></a> Spring JDBC</h2><ul><li>Spring’s datasource initializer via Spring Boot will by default load <code>schema.sql</code> and <code>data.sql</code> from the root of the class path</li><li>Spring Boot will also load from <code>schema-$&#123;platform&#125;.sql</code> and <code>data-$&#123;platform&#125;.sql</code></li><li>must set <code>spring.datasource.platform</code> property</li><li>may conflict with Hinernate DDL auto property<ul><li>if using Spring datasource initializer, should set DDL auto property to <code>none</code> or <code>validate</code></li></ul></li></ul><h2 id="spring-data-jpa-query-method"><a class="markdownIt-Anchor" href="#spring-data-jpa-query-method"></a> Spring Data JPA Query Method</h2><ul><li>define method in interface</li><li>method name rules: findBy + <code>&lt;PROPERTY_NAME&gt;</code></li><li>it will create the query based on method name and query the database to find the data and return to us.</li><li>no manual implementation needed.</li></ul><h2 id="repository-layer-and-service-layer"><a class="markdownIt-Anchor" href="#repository-layer-and-service-layer"></a> Repository layer and Service layer</h2><ul><li>All your business logic should be in the Service Layer.</li><li>Any access to the Database (any storage) should go to the Repository Layer.</li><li>Lets take an Example. You have to save an entity(Person). But before saving the Person you want to make sure that the Person’s FirstName does not exist already.<br />So the validation part should go to the business layer.<br />In the service Layer</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PersonRepository repository; </span><br><span class="line">public Person save(Person p)&#123;</span><br><span class="line">   Person p &#x3D; findByName(p.getName();</span><br><span class="line">   if (p !&#x3D; null)&#123;</span><br><span class="line">          return some customException();</span><br><span class="line">   &#125;</span><br><span class="line">   return repository.save(p); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Person findByName(String name)&#123;</span><br><span class="line">     return repository.findByName(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>And in your Repository Layer just concentrate on DB Operation.</p></li><li><p><code>View&lt;--&gt;Controller( create instance of Model class)&lt;--&gt;Service&lt;---&gt;Repository</code></p></li></ul><h1 id="lombok"><a class="markdownIt-Anchor" href="#lombok"></a> Lombok</h1><ul><li>hooks in via the annotation processor API</li><li>the raw source code is passed to Lombok for code generation before the Java complier continues</li><li>thus, produces properly compiled Java code in conjunction with the Java compiler</li><li>under the classes you can view the compiled class files</li><li>IntelliJ will decompile to show you the source code</li></ul><h2 id="ides"><a class="markdownIt-Anchor" href="#ides"></a> IDEs</h2><ul><li>since compiled code is change, and source files are not, IDE’s can get confused by this</li><li>more of an issue for IDEs several years old</li><li>modern IDEs such as IntelliJ, Eclipse support Project Lombok</li><li>Plug in Installation may be necessary</li><li>IntelliJ<ul><li>verify you have enabled annotation processing under compiler settings</li></ul></li></ul><h2 id="features-2"><a class="markdownIt-Anchor" href="#features-2"></a> features</h2><ul><li><code>val</code> - local variables declared final</li><li><code>var</code> - mutable local variables</li><li><code>@NonNull</code> - Null check, will throw NPE if parameter is null</li><li><code>@Cleanup</code> - will call close() on resource/connection in finally block</li><li><code>@Getter</code> - creates getter methods for all properties</li><li><code>@Setter</code> - creates setter for all non-final properties</li><li><code>@ToString</code><ul><li>generates String of classname, and each field separated by commas</li><li>optional parameter to include field names</li><li>optional parameter to include call to the super toString method</li></ul></li><li><code>@EqualsAndHashCode</code><ul><li>generates implementations of <code>equals(Object other)</code> and <code>hashCode()</code></li><li>by default will use all non-static, non-transient properties</li><li>can optionally exclude specific properties</li></ul></li><li><code>@NoArgsConstructor</code><ul><li>generates no args constructor</li><li>will cause compiler error if there are final fields</li><li>can optionally force, which will initialize final fields with 0 / false / null</li></ul></li><li><code>@RequiredArgsConstructor</code><ul><li>generates a constructor for all fields that are final or marked @NonNull</li><li>constructor will throw a NullPointerException if any <code>@NonNull</code> fields are null</li></ul></li><li><code>@AllArgsConstructor</code><ul><li>generates a constructor for all properties of class</li><li>any @NotNull properties will have null check</li></ul></li><li><code>@Data</code><ul><li>generates typical boilerplate code for POJOs</li><li>combines - <code>@Getter</code>, <code>@Setter</code>, <code>@ToString</code>, <code>@EqualsAndHashCode</code>, <code>@RequiredArgsConstructor</code></li><li>no constructor is generated if constructors have been explicitly declared</li></ul></li><li><code>@Value</code><ul><li>the immutable variant of <code>@Data</code></li><li>all fields are made private and final by default</li></ul></li><li><code>@NonNull</code><ul><li>set on parameter of method or constructor and a NullPointerException will be thrown if parameter is null</li></ul></li><li><code>@Builder</code><ul><li>implements the builder pattern for object creation</li></ul></li><li><code>@SneakyThrows</code><ul><li>throw checked exceptions without declaring in calling method’s throws clause</li></ul></li><li><code>@Synchronized</code><ul><li>a safer implementation of Java’s synchronized</li></ul></li><li><code>@Getter(lazy = true)</code><ul><li>for expensive getters</li><li>will calculate value first time and cache</li><li>additional gets will read from cache</li></ul></li><li><code>@Log</code><ul><li>creates a Java util logger</li></ul></li><li><code>@Slf4j</code><ul><li>creates a SLF4J logger</li><li>recommended - SLF4J is a generic logging facade</li><li>spring boot’s default logger is LogBack</li></ul></li></ul><h1 id="testing-terminology"><a class="markdownIt-Anchor" href="#testing-terminology"></a> Testing Terminology</h1><ul><li>Code under test<ul><li>this is the code you are testing</li></ul></li><li>Test fixture<ul><li>a test fixture is a fixed state of a set of objects used as a baseline for running tests. The purpose of a test fixture is to ensure that there is a well known and fixed environment in which tests are run so that results are repeatable</li><li>includes: input data, mock objects, loading database with known data etc…</li></ul></li></ul><h2 id="unit-tests"><a class="markdownIt-Anchor" href="#unit-tests"></a> Unit Tests</h2><ul><li>code written to test code under test</li><li>designed to test specific sections of code</li><li>percentage of lines of code tested is code coverage<ul><li>ideal coverage is in the 70-80% range</li></ul></li><li>should be unity and execute very fast</li><li>should have no external dependencies<ul><li>no databases, no Spring Context etc…</li></ul></li></ul><h2 id="integration-tests"><a class="markdownIt-Anchor" href="#integration-tests"></a> Integration tests</h2><ul><li>designed to test behaviors between objects and parts of the overall system</li><li>much larger scope</li><li>can include Spring Context, database, and message brokers</li><li>will run much slower than unit tests</li></ul><h2 id="functional-tests"><a class="markdownIt-Anchor" href="#functional-tests"></a> Functional tests</h2><ul><li>typically means you are testing the running application</li><li>application is live, likely deployed in a known environment</li><li>functional touch points are tested</li><li>i.e. using a web driver, calling web services, sending / receiving messages etc…(Selenium)</li></ul><h2 id="tdd"><a class="markdownIt-Anchor" href="#tdd"></a> TDD</h2><ul><li>test driven development</li><li>write tests first, which will fail, then code to fix the tests</li></ul><h2 id="bdd"><a class="markdownIt-Anchor" href="#bdd"></a> BDD</h2><ul><li>behavior driven development</li><li>builds on TDD and specifies that tests of any unit of software should be specified in terms of desired behavior of the unit<ul><li>often implemented with DSLs to create natural language tests</li><li>JBehave, Cucumber, Spock</li></ul></li></ul><h2 id="mock"><a class="markdownIt-Anchor" href="#mock"></a> Mock</h2><ul><li>a fake implementation of a class used for testing, like a test double</li></ul><h2 id="spy"><a class="markdownIt-Anchor" href="#spy"></a> Spy</h2><ul><li>a partial mock, allowing you to override select methods of a real class</li></ul><h2 id="testing-goals"><a class="markdownIt-Anchor" href="#testing-goals"></a> Testing goals</h2><ul><li>generally, you will want the majority of your tests to be unit tests</li><li>bringing up the Spring Context makes your tests exponentially slower</li><li>try to test specific business logic in unit tests</li><li>use Integration tests to test interactions</li><li>think of a pyramid, base is unit tests, middle is integration tests, top is functional tests</li></ul><h2 id="test-scope-dependencies"><a class="markdownIt-Anchor" href="#test-scope-dependencies"></a> Test scope dependencies</h2><ul><li>using spring-boot-starter-test<ul><li>JUnit - the default standard for unit testing Java applications</li><li>Spring test and Spring boot Test - utilities and integration test support for Spring Boot applications</li><li>AssertJ - a fluent assertion library</li><li>Hamcrest - a library of matcher objects</li><li>Mockito - a Java mocking framework</li><li>JSONassert - an assertion library for JSON</li><li>JSONPath - XPath for JSON</li></ul></li></ul><h2 id="junit-annotations"><a class="markdownIt-Anchor" href="#junit-annotations"></a> JUnit Annotations</h2><table><thead><tr><th>Annotation</th><th>Description</th></tr></thead><tbody><tr><td>@Test</td><td>identifies a method as a test method</td></tr><tr><td>@Before</td><td>executed before each test, it is used to prepare the test environment (e.g. read input data, initialize the class)</td></tr><tr><td>@After</td><td>executed after each test, it is used to cleanup the test environment, it can also save memory by cleaning up expensive memory structures</td></tr><tr><td>@BeforeClass</td><td>executed once, before the start of all tests, methods marked with this annotation need to be defined as static to work with JUnit</td></tr><tr><td>@AfterClass</td><td>executed once, after all tests have been finished, methods annotated with this annotation need to be defined as static to work with JUnit</td></tr><tr><td>@Ignore</td><td>marks that the test should be ignored</td></tr><tr><td>@Test(expected = Exception.class)</td><td>fails if the method does not throw the named exception</td></tr><tr><td>@Test(timeout = 10)</td><td>fails if the method takes longer than 100 milliseconds</td></tr></tbody></table><h2 id="spring-boot-annotations"><a class="markdownIt-Anchor" href="#spring-boot-annotations"></a> Spring Boot Annotations</h2><table><thead><tr><th>Annotation</th><th>Description</th></tr></thead><tbody><tr><td>@RunWith(SpringRunner.class)</td><td>run test with Spring Context</td></tr><tr><td>@SpringBootTest</td><td>search for Spring boot application for configuration</td></tr><tr><td>@TestConfiguration</td><td>specify a Spring configuration for you test</td></tr><tr><td>@MockBean</td><td>injects Mockito mock</td></tr><tr><td>@SpyBean</td><td>injects Mockito Spy</td></tr><tr><td>@JsonTest</td><td>creates a Jackson or Gson object mapper via Spring boot</td></tr><tr><td>@WebMvcTest</td><td>used to test web context without a full http server</td></tr><tr><td>@DataJpaTest</td><td>used to test data layer with embedded database</td></tr></tbody></table><p>…</p><h2 id="argumentcaptor"><a class="markdownIt-Anchor" href="#argumentcaptor"></a> ArgumentCaptor</h2><ul><li>ArgumentCaptor allows us to capture an argument passed to a method in order to inspect it. This is especially useful when we can’t access the argument outside of the method we’d like to test.</li><li>For example, consider an EmailService class with a send method that we’d like to test:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class EmailService &#123;</span><br><span class="line"></span><br><span class="line">    private DeliveryPlatform platform;</span><br><span class="line"></span><br><span class="line">    public EmailService(DeliveryPlatform platform) &#123;</span><br><span class="line">        this.platform &#x3D; platform;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void send(String to, String subject, String body, boolean html) &#123;</span><br><span class="line">        Format format &#x3D; Format.TEXT_ONLY;</span><br><span class="line">        if (html) &#123;</span><br><span class="line">            format &#x3D; Format.HTML;</span><br><span class="line">        &#125;</span><br><span class="line">        Email email &#x3D; new Email(to, subject, body);</span><br><span class="line">        email.setFormat(format);</span><br><span class="line">        platform.deliver(email);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>In EmailService.send, notice how platform.deliver takes a new Email as an argument. As part of our test, we’d like to check that the format field of the new Email is set to Format.HTML. In order to do this, we need to capture and inspect the argument that is passed to platform.deliver.</li></ul><h3 id="set-up-the-unit-test"><a class="markdownIt-Anchor" href="#set-up-the-unit-test"></a> Set up the unit test</h3><ul><li>First, let’s create our unit test class:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RunWith(MockitoJUnitRunner.class)</span><br><span class="line">public class EmailServiceUnitTest &#123;</span><br><span class="line"></span><br><span class="line">    @Mock</span><br><span class="line">    DeliveryPlatform platform;</span><br><span class="line"></span><br><span class="line">    @InjectMocks</span><br><span class="line">    EmailService emailService;</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>We’re using the @Mock annotation to mock DeliveryPlatform, which is automatically injected into our EmailService with the @InjectMocks annotation.</li></ul><h3 id="add-an-argumentcaptor-field"><a class="markdownIt-Anchor" href="#add-an-argumentcaptor-field"></a> Add an ArgumentCaptor field</h3><ul><li>Second, let’s add a new ArgumentCaptor field of type Email to store our captured argument:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Captor</span><br><span class="line">ArgumentCaptor&lt;Email&gt; emailCaptor;</span><br></pre></td></tr></table></figure><h3 id="capture-the-argument"><a class="markdownIt-Anchor" href="#capture-the-argument"></a> Capture the argument</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mockito.verify(platform).deliver(emailCaptor.capture());</span><br></pre></td></tr></table></figure><ul><li>We can then get the captured value and store it as a new Email object:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Email emailCaptorValue &#x3D; emailCaptor.getValue();</span><br></pre></td></tr></table></figure><h3 id="inspect-the-captured-value"><a class="markdownIt-Anchor" href="#inspect-the-captured-value"></a> Inspect the captured value</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void whenDoesSupportHtml_expectHTMLEmailFormat() &#123;</span><br><span class="line">    String to &#x3D; &quot;info@baeldung.com&quot;;</span><br><span class="line">    String subject &#x3D; &quot;Using ArgumentCaptor&quot;;</span><br><span class="line">    String body &#x3D; &quot;Hey, let&#39;use ArgumentCaptor&quot;;</span><br><span class="line"></span><br><span class="line">    emailService.send(to, subject, body, true);</span><br><span class="line"></span><br><span class="line">    Mockito.verify(platform).deliver(emailCaptor.capture());</span><br><span class="line">    Email value &#x3D; emailCaptor.getValue();</span><br><span class="line">    assertEquals(Format.HTML, value.getFormat());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="exception-handling-in-spring-mvc"><a class="markdownIt-Anchor" href="#exception-handling-in-spring-mvc"></a> Exception Handling in Spring MVC</h1><h2 id="http-status-code"><a class="markdownIt-Anchor" href="#http-status-code"></a> HTTP status code</h2><ul><li>HTTP 5XX server error<ul><li>HTTP 500 - internal server error</li><li>generally, any unhandled exception</li><li>other 500 errors are generally not used with Spring MVC</li></ul></li><li>HTTP 4XX client errors - generally checked exceptions<ul><li>400 bad request - cannot process due to client error</li><li>401 unauthorized - authentication required</li><li>404 not found - resource not found</li><li>405 method not allowed, HTTP method not allowed</li></ul></li></ul><h2 id="responsestatus"><a class="markdownIt-Anchor" href="#responsestatus"></a> @ResponseStatus</h2><ul><li>allows you to annotate custom exception classes to indicate to the framework the HTTP status you want returned when that exception is thrown</li><li>global to the application</li></ul><h2 id="exceptionhandler"><a class="markdownIt-Anchor" href="#exceptionhandler"></a> @ExceptionHandler</h2><ul><li>works at the controller level</li><li>allows you to define custom exception handling</li><li>can be used with <code>@ResponseStatus</code> for just printing a http status</li><li>can be used to return a specific view</li><li>also can take total control and work with the Model and View</li><li>Model cannot be a parameter of an ExceptionHandler method</li></ul><h2 id="handlerexceptionresolver"><a class="markdownIt-Anchor" href="#handlerexceptionresolver"></a> @HandlerExceptionResolver</h2><ul><li>is an interface you can implement for custom exception handling</li><li>used internally by Spring MVC</li><li>note Model is not passed</li></ul><h1 id="docker"><a class="markdownIt-Anchor" href="#docker"></a> Docker</h1><h2 id="what-is-docker"><a class="markdownIt-Anchor" href="#what-is-docker"></a> What is Docker?</h2><ul><li>Docker is a standard for Linux containers</li><li>a Container is an isolated runtime inside of Linux</li><li>a Container provides a private machine like space under Linux</li><li>Containers will run under any modern Linux Kernel</li></ul><h2 id="containers-can"><a class="markdownIt-Anchor" href="#containers-can"></a> Containers can</h2><ul><li>Have their own process space</li><li>their own network interface</li><li>run processes as Root (inside the container)</li><li>have their own disk space<ul><li>can share with host too</li></ul></li><li>Container is not a VM</li></ul><h2 id="docker-terminology"><a class="markdownIt-Anchor" href="#docker-terminology"></a> Docker Terminology</h2><ul><li>Docker Image - the representation of a Docker container, kind of like a JAR or WAR file in Java</li><li>Docker Container - the standard runtime of Docker, effectively a deployed and running Docker image, like a Spring Boot Executable JAR</li><li>Docker Engine - the code which manages Docker stuff, creates and runs Docker containers</li></ul><h2 id="notes-about-docker-images-and-containers"><a class="markdownIt-Anchor" href="#notes-about-docker-images-and-containers"></a> Notes about Docker Images and Containers</h2><ul><li>Containers are like snapshots of Docker images</li><li>Docker images are built by Docker files which contains multiple layers, each layer is a Command and will generate a file for the image. The layers will be re-created everytime when we run a new container for an image.</li><li>e.g. when you <code>docker run -d mongo</code>, a new container for the image <code>mongo</code> will be created, and there is a layer for this container where you can store data in it. But when you <code>docker stop &lt;Container_ID&gt;</code> and re-start using <code>docker run -d mongo</code>, a new container with different Container ID will be created, so your old data in the previous container will not show in your new container. You can map a storage path to the container, so the current container and all future containers will save data into the directory you setup. Which will make the data persistence.</li></ul><h2 id="docker-housekeeping"><a class="markdownIt-Anchor" href="#docker-housekeeping"></a> Docker housekeeping</h2><h3 id="cleaning-up-after-docker"><a class="markdownIt-Anchor" href="#cleaning-up-after-docker"></a> Cleaning up after Docker</h3><ul><li>with development use docker can leave behind a lot of files</li><li>these files will grow and consume a lot of disk space</li><li>this is less of an issue on production systems where containers aren’t being built and restarted all the time</li><li>there are 3 key areas of house keeping<ul><li>containers</li><li>images</li><li>volumes</li></ul></li></ul><h1 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> MySQL</h1><h2 id="mysql-features"><a class="markdownIt-Anchor" href="#mysql-features"></a> MySQL features</h2><ul><li>Stored procedures<ul><li>a piece of code inside of the database that execute against the database, runs locally on the database</li></ul></li><li>Triggers<ul><li>when something happens in the database e.g. insert a record, the trigger will run before or after that transaction</li></ul></li><li>Cursors<ul><li>point a place in a large set of data so you can scroll through it and look into the next record or previous record.</li></ul></li><li>Updated views<ul><li>a virtual table, stored inside the database</li></ul></li><li>Query cache<ul><li>database is going to remember in memory the result of your query, when you ask for that data again, it doesn’t have to go back to the file system to get the data.</li></ul></li><li>Subselects<ul><li>nested queries.</li></ul></li></ul><h2 id="acid-compliance"><a class="markdownIt-Anchor" href="#acid-compliance"></a> ACID compliance</h2><ul><li>atomicity - all or nothing</li><li>consistency - transactions are valid to rules of the DB</li><li>isolation - results of transactions are as if they are done end to end</li><li>durability - once a transaction is committed, it remains so (DB will not losing data)</li></ul><h2 id="rdbms-deployment-architectures"><a class="markdownIt-Anchor" href="#rdbms-deployment-architectures"></a> RDBMS deployment architectures</h2><ul><li>typically is driven by needs of scalability and availability</li><li>can be done on a single non-dedicated server or many dedicated servers</li><li>communication is typically over a network socket (MySQL: 3306)</li><li>the client will need software called a <code>driver</code> to talk to the database over the network socket.</li></ul><h2 id="mysql-data-types"><a class="markdownIt-Anchor" href="#mysql-data-types"></a> MySQL data types</h2><ul><li>a data type defines the data type of a column</li><li>MySQL does support the standard ANSI SQL data types</li><li>data types are broken down into the following categories<ul><li>numeric</li><li>date and time</li><li>string</li><li>spatial (location, places)</li><li>JSON</li></ul></li></ul><h2 id="mysql-installation-options"><a class="markdownIt-Anchor" href="#mysql-installation-options"></a> MySQL installation options</h2><h3 id="native-installation"><a class="markdownIt-Anchor" href="#native-installation"></a> Native installation</h3><ul><li>meaning install on your opearting system</li></ul><h3 id="running-mysql-in-a-container"><a class="markdownIt-Anchor" href="#running-mysql-in-a-container"></a> Running MySQL in a Container</h3><ul><li>MySQL can also be run inside a technology called containers</li><li>Docker is a highly popular container technology</li><li>through Docker, you can run MySQL locally using pre built image from Docker hub</li></ul><h2 id="connecting-to-mysql"><a class="markdownIt-Anchor" href="#connecting-to-mysql"></a> Connecting to MySQL</h2><ul><li>Local connection<ul><li>connecting to MySQL from the command line on the machine running MySQL</li><li>to login to docker: <code>docker exec -it yuan-mysql bash</code></li><li>to connect to mysql server in Docker: <code>mysql --user=root -p</code></li></ul></li><li>remote / client connection<ul><li>using some type of client software on the same machine running MySQL</li><li>or connecting to the MySQL server from a different machine over the network</li></ul></li></ul><h1 id="mongo-db"><a class="markdownIt-Anchor" href="#mongo-db"></a> Mongo DB</h1><h2 id="about-mongo-db"><a class="markdownIt-Anchor" href="#about-mongo-db"></a> About Mongo DB</h2><ul><li>Mongo DB is a document oriented database</li><li>developed in C++</li><li>MongoDB is a NoSQL database</li><li>MongoDB documents are stored in BSON<ul><li>binary JSON</li></ul></li></ul><h2 id="why-use-mongo-db"><a class="markdownIt-Anchor" href="#why-use-mongo-db"></a> Why use Mongo DB?</h2><ul><li>MongoDB is great for high insert systems<ul><li>such as sensor readings, social media systems, advertising systems</li></ul></li><li>good when you need schema flexibility</li><li>can also support a high number of reads per second</li></ul><h2 id="why-avoid-mongodb"><a class="markdownIt-Anchor" href="#why-avoid-mongodb"></a> Why avoid MongoDB?</h2><ul><li>MongoDB has no concept of transactions<ul><li>No ACID</li><li>no locking for transactional support, hence faster inserts</li></ul></li><li>not good for concurrent updates</li></ul><h1 id="reactive-manifesto"><a class="markdownIt-Anchor" href="#reactive-manifesto"></a> Reactive Manifesto</h1><h2 id="responsive"><a class="markdownIt-Anchor" href="#responsive"></a> Responsive</h2><ul><li>the system responds in a timely manner</li><li>responsiveness is the cornerstone of useability and utility</li><li>responsiveness also means problems may be detected quickly and dealt with effectively</li><li>responsive systems provide rapid and consistent response times</li><li>consistent behavior simplifies error handling, builds end user confidence, and encourages further interaction</li></ul><h2 id="resilient"><a class="markdownIt-Anchor" href="#resilient"></a> Resilient</h2><ul><li>system stays responsive in the face of failure</li><li>resilience is achieved by replication, containment, isolation and delegation</li><li>failures are contained within each component</li><li>parts of the system can fail, without compromising the system as a whole</li><li>recovery of each component is delegated to another</li><li>high availability is ensured by replication where necessary</li></ul><h2 id="elastic"><a class="markdownIt-Anchor" href="#elastic"></a> Elastic</h2><ul><li>the system stays responsive under varying workload</li><li>reactive systems can react to changes in the input rate by increasing or decreasing resources allocated to service inputs</li><li>reactive systems achieve elasticity ina cost effective way on commodity hardware and software platforms</li></ul><h2 id="message-driven"><a class="markdownIt-Anchor" href="#message-driven"></a> Message Driven</h2><ul><li>reactive systems rely on asynchronous message passing to establish a boundary between components<ul><li>this ensures loose coupling, isolation, and location transparency</li></ul></li><li>message passing enables load management, elasticity, and flow control</li><li>location transparent messaging makes management of failure possible</li><li>non blocking communication allows recipients to only consume resources while active, leading to less system overhead.</li></ul><h2 id="reactive-programming-with-reactive-systems"><a class="markdownIt-Anchor" href="#reactive-programming-with-reactive-systems"></a> reactive programming with reactive systems</h2><ul><li>reactive programming is a useful implementation technique</li><li>reactive programming focuses on non-blocking, asynchronous execution - a key characteristic of reactive systems</li><li>reactive programming is just one tool in building reactive systems</li></ul><h1 id="reactive-programming"><a class="markdownIt-Anchor" href="#reactive-programming"></a> Reactive Programming</h1><ul><li>reactive programming is an asynchronous programming paradigm focused on streams of data</li><li>reactive programs also maintain a continuous interaction with their environment, but at a speed which is determined by the environment, not the program itself. Interactive programs work at their own pace and mostly deal with communication, while reactive programs only work in response to external demands and mostly deal with accurate interrupt handling, real time programs are usually reactive.</li></ul><h2 id="common-use-cases"><a class="markdownIt-Anchor" href="#common-use-cases"></a> Common use cases</h2><ul><li>external service calls</li><li>highly concurrent message consumers</li><li>spreadsheets</li><li>abstraction over asynchronous processing<ul><li>abstract whether or not your program is synchronous or asynchronous</li></ul></li></ul><h2 id="features-opf-reactive-programming"><a class="markdownIt-Anchor" href="#features-opf-reactive-programming"></a> features opf reactive programming</h2><ul><li>data streams</li><li>asynchronous</li><li>non-blocking</li><li>backpressure</li><li>failures as messages</li></ul><h2 id="data-streams"><a class="markdownIt-Anchor" href="#data-streams"></a> data streams</h2><ul><li>data streams can be just about anything</li><li>mouse clicks, or other user interactions</li><li>JMS messages, RESTful service calls, Twitter feed, Stock trades, list of data from a database</li><li>a stream is a sequence of events ordered in time</li><li>events you want to listen to</li></ul><h2 id="asynchronous"><a class="markdownIt-Anchor" href="#asynchronous"></a> Asynchronous</h2><ul><li>events are captured asynchronously</li><li>a function is defined to execute when an event is emitted</li><li>another function is defined if an error is emitted</li><li>another function is defined when complete is emitted</li></ul><h2 id="observer-pattern"><a class="markdownIt-Anchor" href="#observer-pattern"></a> Observer pattern</h2><ul><li>you have a subject and an observer</li><li>when the subject is going to change, it will notify the observer</li></ul><h2 id="non-blocking"><a class="markdownIt-Anchor" href="#non-blocking"></a> Non-blocking</h2><ul><li>the concept of using non blocking is important</li><li>in blocking, the code will stop and wait for more dta (reading from disk, network etc…)</li><li>non blocking in contrast, will process available data, ask to be notified when more is available, then continue</li></ul><h2 id="back-pressure"><a class="markdownIt-Anchor" href="#back-pressure"></a> back pressure</h2><ul><li>the ability of the subscriber to throttle data</li></ul><h2 id="failures-as-messages"><a class="markdownIt-Anchor" href="#failures-as-messages"></a> failures as messages</h2><ul><li>exceptions are not thrown in a traditional sense<ul><li>would break processing of stream</li></ul></li><li>exceptions are processed by a handler function</li></ul><h1 id="reactive-streams"><a class="markdownIt-Anchor" href="#reactive-streams"></a> Reactive Streams</h1><h2 id="spring-reactive-types"><a class="markdownIt-Anchor" href="#spring-reactive-types"></a> Spring Reactive Types</h2><ul><li>two new reactive types are introduced with Spring framework 5</li><li><code>Mono</code> is a publisher with zero or one elements in data stream</li><li><code>Flux</code> is a publisher with zero or MANY elements in the data stream</li><li>both types implement the reactive streams publisher interface</li></ul><h1 id="webflux"><a class="markdownIt-Anchor" href="#webflux"></a> WebFlux</h1><table><thead><tr><th>web MVC</th><th>webFlux</th></tr></thead><tbody><tr><td>@Controller, @RequestMapping</td><td>Router functions</td></tr><tr><td>spring-webmvc</td><td>spring-webflux</td></tr><tr><td>Servlet API</td><td>HTTP / Reactive Streams</td></tr><tr><td>Servlet Container</td><td>Tomcat, Jetty, Netty, Undertow</td></tr></tbody></table><h1 id="restful-web-services"><a class="markdownIt-Anchor" href="#restful-web-services"></a> RESTful web services</h1><ul><li>because of their simplicity and versatility, RESTful web services have become the de facto standard for web services</li><li>REST - representational state transfer<ul><li>representational - typically JSON or XML</li><li>state transfer - typically via HTTP</li></ul></li></ul><h2 id="terminology"><a class="markdownIt-Anchor" href="#terminology"></a> terminology</h2><ul><li>verbs - HTTP methods: GET, PUT, POST, DELETE</li><li>messages - the payload of the action(JSON / XML)</li><li>URI - uniform resource identifier<ul><li>a unique string identifying a resource</li></ul></li><li>URL - uniform resource locator<ul><li>a URI with network information</li></ul></li><li>Idempotence<ul><li>the property of certain operations in mathematics and computer science that they can be applied multiple times without changing the result beyond the initial application</li><li>in other words, you can exercise the operation multiple times, without changing the result</li><li>example: refreshing a web page (HTTP GET operation)</li></ul></li><li>Stateless - service does not maintain any client state</li><li>HATEOAS - hypermedia as the engine of application state<ul><li>a REST client should then be able to use server-provided links dynamically to discover all the available actions and resources it needs, as access proceeds, the server responds with text that includes hyperlinks to other actions that are currently available</li></ul></li></ul><h2 id="get"><a class="markdownIt-Anchor" href="#get"></a> GET</h2><ul><li>use: to read data from resource</li><li>read only</li><li>idempotent</li><li>safe operation - does not change state of resource</li></ul><h2 id="put"><a class="markdownIt-Anchor" href="#put"></a> PUT</h2><ul><li>use: to insert or update</li><li>idempotent - multiple PUT will not change result</li><li>like saving a file multiple times</li><li>not safe operation - does change state of resource</li></ul><h2 id="post"><a class="markdownIt-Anchor" href="#post"></a> POST</h2><ul><li>use: to create new object</li><li>non-idempotent - multiple POSTs is expected to create multiple objects</li><li>not safe operation - does change state of resource</li><li>only non-idempotent, non-safe HTTP verb</li></ul><h2 id="delete"><a class="markdownIt-Anchor" href="#delete"></a> DELETE</h2><ul><li>use: to delete an object</li><li>idempotent - multiple DELETEs will have same effect / behavior</li><li>not safe operation, does change the state of resource</li></ul><h1 id="mapstruct"><a class="markdownIt-Anchor" href="#mapstruct"></a> MapStruct</h1><ul><li>MapStruct is a code generator for Java bean mapping<ul><li>helps reduce coding for type conversions</li><li>when dealing with Rest services, a common use case is to expose API data using DTOs (Data Transfer Object)</li><li>as project grows bigger, it is not good to expose POJO directly to Rest services. MapStruct is helping us to convert POJO to DTOs, then export DTOs to Rest service to be consumed by public</li></ul></li></ul><h1 id="content-negotiation"><a class="markdownIt-Anchor" href="#content-negotiation"></a> Content Negotiation</h1><h2 id="content-negotiating-view-resolver"><a class="markdownIt-Anchor" href="#content-negotiating-view-resolver"></a> Content Negotiating view resolver</h2><ul><li>used by Spring MVC to determine view handler to use</li><li>auto configured by Spring boot</li><li>the content negotiating view resolver will determine the view to use to render the data of the model to the client</li></ul><h2 id="content-type"><a class="markdownIt-Anchor" href="#content-type"></a> Content type</h2><ul><li>view to use is determined by Content Type in HTTP header<ul><li>application/json, application/xml, text/html</li></ul></li><li>if view for requested Content type is not found, HTTP status 406 not acceptable is returned.</li></ul><h1 id="helper-library-and-classes"><a class="markdownIt-Anchor" href="#helper-library-and-classes"></a> Helper Library and Classes</h1><h2 id="structure"><a class="markdownIt-Anchor" href="#structure"></a> Structure</h2><ul><li>the project should follow a structure from database to frontend: Database -&gt; Repository -&gt; Service -&gt; Controller -&gt; View</li></ul><h2 id="jpa"><a class="markdownIt-Anchor" href="#jpa"></a> JPA</h2><ul><li>H2 in memory database</li></ul><h2 id="thymeleaf-2"><a class="markdownIt-Anchor" href="#thymeleaf-2"></a> Thymeleaf</h2><ul><li>frontend template engine, model can be added to view dynamically</li></ul><h2 id="dependency-injection"><a class="markdownIt-Anchor" href="#dependency-injection"></a> Dependency Injection</h2><ul><li>Repositories and Services can be injected when needed, use Annotations @Service, @Component</li><li>classes marked as @Component, @Service and @Controller will be managed by Spring Application Context, it will inject necessary class to the right place when needed. (Beans)</li></ul><h2 id="configuration"><a class="markdownIt-Anchor" href="#configuration"></a> Configuration</h2><ul><li>config files can be Java, YAML, or XML</li><li>application.properties can define project profiles</li></ul><h2 id="jpa-entity-relationships"><a class="markdownIt-Anchor" href="#jpa-entity-relationships"></a> JPA entity relationships</h2><ul><li>One to Many</li><li>Many to One</li><li>Many to Many (needs mapping table)</li></ul><h2 id="jpa-query-methods"><a class="markdownIt-Anchor" href="#jpa-query-methods"></a> JPA Query methods</h2><ul><li>e.g. findByDescription</li><li>this is done by the library, findBy + property name</li><li>library will do the implementations for you</li></ul><h2 id="project-lombok"><a class="markdownIt-Anchor" href="#project-lombok"></a> Project Lombok</h2><ul><li>will do the constructors, getters, setters and even builder patterns for you</li></ul><h2 id="junit"><a class="markdownIt-Anchor" href="#junit"></a> JUnit</h2><ul><li>Unit Test framework</li></ul><h2 id="mockito"><a class="markdownIt-Anchor" href="#mockito"></a> Mockito</h2><ul><li>for unit tests, we do not want to bring in Spring Application Context</li><li>so to manage Repositories and Services, we need Mockito to create some Mock component for us</li><li>when(), thenReturn(), verify(), ArgumentCaptor, MockMvc…</li></ul><h2 id="webjars"><a class="markdownIt-Anchor" href="#webjars"></a> WebJars</h2><ul><li>bring in bootstrap library</li></ul><h2 id="web-data-binder"><a class="markdownIt-Anchor" href="#web-data-binder"></a> Web Data Binder</h2><ul><li>binds HTTP variables to Java object</li><li>specifically handling form posts and binding form variables to Java data objects</li><li>whereas Rest service we could use RestTemplate</li></ul><h2 id="validations"><a class="markdownIt-Anchor" href="#validations"></a> Validations</h2><ul><li>@NotBlank, @NotNull, @Max, @Min…</li><li>annotations to data models, for form validations</li></ul><h2 id="exceptions"><a class="markdownIt-Anchor" href="#exceptions"></a> Exceptions</h2><ul><li>@ResponseStatus</li><li>@ControllerAdvice</li><li>dealing with exceptions and custom error messages</li></ul><h2 id="reactive-programming-2"><a class="markdownIt-Anchor" href="#reactive-programming-2"></a> Reactive Programming</h2><ul><li>Mono, Flux</li><li>WebFlux</li><li>Reactive vs Servlet</li></ul><h2 id="resttemplate"><a class="markdownIt-Anchor" href="#resttemplate"></a> RestTemplate</h2><ul><li>bind Rest Response to Java objects</li></ul><h2 id="webclient"><a class="markdownIt-Anchor" href="#webclient"></a> WebClient</h2><ul><li>performing web request</li></ul><h2 id="mapstruct-2"><a class="markdownIt-Anchor" href="#mapstruct-2"></a> MapStruct</h2><ul><li>auto mapper</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;spring-framework-stereotypes&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#spring-framework-stereotypes&quot;&gt;&lt;/a&gt; Spring Framework Stereotypes&lt;/h</summary>
      
    
    
    
    
    <category term="Spring" scheme="http://hellcy.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
